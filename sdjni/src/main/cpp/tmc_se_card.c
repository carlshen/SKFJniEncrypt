

#include <stdlib.h>
#include <string.h>

#include <jni.h>
#include "sdk.h"
#include "base_type.h"

#define SOPIN	2
#define UserPIN	1

#define PUBLIC_OBJECT	0
#define PRIVATE_OBJECT	1

#define ATTR_ZONE	0
#define VALUE_ZONE	1

u8 apdu_createFile[4] = {0x80, 0xE0, 0x00, 0x00};
u8 apdu_deleteFile[4] = {0x80, 0xE4, 0x00, 0x00};
u8 apdu_selectFile[4] = {0x00, 0xA4, 0x00, 0x00};
u8 apdu_writeKey[4] = {0x80, 0xD4, 0x01, 0x00};
u8 apdu_readBin[4] = {0x00, 0xB0, 0x00, 0x00};
u8 apdu_updateBin[4] = {0x00, 0xD6, 0x00, 0x00};
u8 apdu_readObject[4] = {0x80, 0xB4, 0x00, 0x00};
u8 apdu_updateObject[4] = {0x80, 0xD8, 0x00, 0x00};
u8 apdu_endPersonal[4] = {0x80, 0xE0, 0x02, 0x00};
u8 apdu_verifyPIN[4] = {0x00, 0x20, 0x00, 0x00};
u8 apdu_changePIN[4] = {0x80, 0x5E, 0x01, 0x00};
u8 apdu_verifyTK[4] = {0x80, 0x82, 0x00, 0x01};
u8 apdu_changeTK[4] = {0x80, 0x86, 0x00, 0x00};
u8 apdu_getInfo[4] = {0x80, 0xCA, 0x00, 0x00};
u8 apdu_clearSecurityState[4] = {0x80, 0xC4, 0x00, 0x00};
u8 apdu_generateKey[4] = {0x80, 0xC8, 0x00, 0x00};
u8 apdu_importKey[4] = {0x80, 0xCC, 0x01, 0x00};
u8 apdu_exportKey[4] = {0x80, 0xCE, 0x01, 0x00};
u8 apdu_generateEnv[4] = {};
u8 apdu_openEnv[4] = {};
u8 apdu_exchangeKey[4] = {0x80, 0xF4, 0x00, 0x00};
u8 apdu_deriveKey[4] = {};
u8 apdu_symAlgOpera[4] = {0x80, 0xF8, 0x00, 0x00};
u8 apdu_asymAlgOpera[4] = {0x80, 0xFA, 0x01, 0x00};
u8 apdu_hashOpera[4] = {0x80, 0xFC, 0x01, 0x00};
u8 apdu_getChallenge[4] = {0x00, 0x84, 0x00, 0x00};
u8 apdu_getUID[4] = {0x80, 0xCA, 0x01, 0x00};
u8 apdu_getRespData[4] = {0x80, 0xC6, 0x00, 0x00};
u8 apdu_getResp[4] = {0x00, 0xC0, 0x00, 0x00};

u8 apduBuf[SC_MAX_CACHE_SIZE] = {0};

int tmc_apdu_to_buf(tmc_apdu_t * apdu, u8 *out)
{
    u8 * tmp = out;


    if (out == NULL)
        return SC_ERROR_INVALID_ARGUMENTS;

    *tmp++ = apdu->cla;
    *tmp++ = apdu->ins;
    *tmp++ = apdu->p1;
    *tmp++ = apdu->p2;


    switch (apdu->cse)
    {
        case SC_APDU_CASE_1:
            *tmp = (u8)0x00;
            break;
        case SC_APDU_CASE_2_SHORT:
            *tmp = (u8)apdu->le;
            break;
        case SC_APDU_CASE_3_SHORT:
            *tmp++ = (u8)apdu->lc;
            memcpy(tmp, apdu->data, apdu->lc);
            break;
        case SC_APDU_CASE_4_SHORT:
            *tmp++ = (u8)apdu->lc;
            memcpy(tmp, apdu->data, apdu->lc);
            tmp[apdu->lc] = (u8)apdu->le;
            break;

    }

    return SC_SUCCESS;

}

static void tmc_format_apdu(tmc_apdu_t *apdu, int cse, u8* apdu_head)
{
	memset(apdu, 0, sizeof(*apdu));

	apdu->cse = cse;

	apdu->cla = (u8)apdu_head[0];

	apdu->ins = (u8)apdu_head[1];

	apdu->p1 = (u8)apdu_head[2];

	apdu->p2 = (u8)apdu_head[3];


}

struct tmcse_drv_data
{
	/* Save the current algorithm reference
     * (SC_ALG_REF_ECDSA, SC_ALG_REF_RSA_PAD_PKCS1)
     * to be able to distinguish between RSA and ECC operations.
     * If ECC is being used, the signatures generated by the card
     * have to be modified. */
	unsigned int sec_env_alg_ref;
	unsigned int sec_env_ec_field_length;
	unsigned int tmcse_version;
};

static struct tmcse_supported_ec_curves {
	struct tmc_object_id oid;
	size_t size;
	unsigned int min_applet_version;
} ec_curves[] = {
		{{{1, 2, 840, 10045, 3, 1, 1, -1}},     192, 0x0000}, /* secp192r1, nistp192, prime192v1, ansiX9p192r1 */
		{{{1, 3, 132, 0, 33, -1}},              224, 0x0000}, /* secp224r1, nistp224 */
		{{{1, 2, 840, 10045, 3, 1, 7, -1}},     256, 0x0000}, /* secp256r1, nistp256, prime256v1, ansiX9p256r1 */
		{{{1, 3, 132, 0, 34, -1}},              384, 0x0000}, /* secp384r1, nistp384, prime384v1, ansiX9p384r1 */
		{{{1, 3, 36, 3, 3, 2, 8, 1, 1, 3, -1}}, 192, 0x0000}, /* brainpoolP192r1 */
		{{{1, 3, 36, 3, 3, 2, 8, 1, 1, 5, -1}}, 224, 0x0000}, /* brainpoolP224r1 */
		{{{1, 3, 36, 3, 3, 2, 8, 1, 1, 7, -1}}, 256, 0x0000}, /* brainpoolP256r1 */
		{{{1, 3, 36, 3, 3, 2, 8, 1, 1, 9, -1}}, 320, 0x0000}, /* brainpoolP320r1 */
		{{{1, 3, 132, 0, 31, -1}},              192, 0x0006}, /* secp192k1 */
		{{{1, 3, 132, 0, 10, -1}},              256, 0x0006}, /* secp256k1 */
		{{{-1}}, 0, 0} /* This entry must not be touched. */
};

void tmc_init_oid(struct tmc_object_id *oid)
{
	int ii;

	if (!oid)
		return;
	for (ii=0; ii<SC_MAX_OBJECT_ID_OCTETS; ii++)
		oid->value[ii] = -1;
}

int _tmc_card_add_algorithm(tmc_card_t *card, const tmc_algorithm_info_t *info)
{
	tmc_algorithm_info_t *p;

	if (info == NULL) {
		return SC_ERROR_INVALID_ARGUMENTS;
	}
	p = (tmc_algorithm_info_t *)realloc(card->algorithms, (card->algorithm_count + 1) * sizeof(*info));
	if (!p) {
		if (card->algorithms)
			free(card->algorithms);
		card->algorithms = NULL;
		card->algorithm_count = 0;
		return SC_ERROR_OUT_OF_MEMORY;
	}
	card->algorithms = p;
	p += card->algorithm_count;
	card->algorithm_count++;
	*p = *info;
	return SC_SUCCESS;
}
int _tmc_card_add_rsa_alg(tmc_card_t *card, unsigned int key_length,
						  unsigned long flags, unsigned long exponent)
{
	tmc_algorithm_info_t info;

	memset(&info, 0, sizeof(info));
	info.algorithm = SC_ALGORITHM_RSA;
	info.key_length = key_length;
	info.flags = flags;
	info.u._rsa.exponent = exponent;

	return _tmc_card_add_algorithm(card, &info);
}

int  _tmc_card_add_ec_alg(tmc_card_t *card, unsigned int key_length,
						  unsigned long flags, unsigned long ext_flags,
						  struct tmc_object_id *curve_oid)
{
	tmc_algorithm_info_t info;

	memset(&info, 0, sizeof(info));
	tmc_init_oid(&info.u._ec.params.id);

	info.algorithm = SC_ALGORITHM_EC;
	info.key_length = key_length;
	info.flags = flags;

	info.u._ec.ext_flags = ext_flags;
	if (curve_oid)
		info.u._ec.params.id = *curve_oid;

	return _tmc_card_add_algorithm(card, &info);
}



int  _tmc_card_add_sm2_alg(tmc_card_t *card, unsigned int key_length,
						   unsigned long flags, unsigned long ext_flags,
						   struct tmc_object_id *curve_oid)
{
	tmc_algorithm_info_t info;

	memset(&info, 0, sizeof(info));
	tmc_init_oid(&info.u._ec.params.id);

	info.algorithm = SC_ALGORITHM_SM2;
	info.key_length = key_length;
	info.flags = flags;

	info.u._ec.ext_flags = ext_flags;
	if (curve_oid)
		info.u._ec.params.id = *curve_oid;

	return _tmc_card_add_algorithm(card, &info);
}


int _tmc_card_add_symmetric_alg(tmc_card_t *card, unsigned int algorithm,
								unsigned int key_length, unsigned long flags)
{
	tmc_algorithm_info_t info;

	memset(&info, 0, sizeof(info));
	info.algorithm = algorithm;
	info.key_length = key_length;
	info.flags = flags;

	return _tmc_card_add_algorithm(card, &info);
}


static CK_RV
tmcse_finish(tmc_card_t *card)
{
	struct tmcse_drv_data *drvdata= card->drv_data;

	if (drvdata)
	{
		free(drvdata);
		card->drv_data=NULL;
	}
	return SC_SUCCESS;

}

static CK_RV
tmcse_init(tmc_card_t *card)
{

	unsigned long flags = 0;
	unsigned long ext_flags = 0;
	struct tmcse_drv_data *drvdata;

	drvdata=calloc(1, sizeof(*drvdata));
	if (!drvdata)
		return SC_ERROR_OUT_OF_MEMORY;

	card->drv_data = drvdata;
	card->cla = 0x00;

	/* show supported symmetric algorithms */
	flags = 0;
	_tmc_card_add_symmetric_alg(card, SC_ALGORITHM_DES, 56, flags);
	_tmc_card_add_symmetric_alg(card, SC_ALGORITHM_3DES, 128, flags);
	_tmc_card_add_symmetric_alg(card, SC_ALGORITHM_3DES, 192, flags);

	_tmc_card_add_symmetric_alg(card, SC_ALGORITHM_AES, 128, flags);
	_tmc_card_add_symmetric_alg(card, SC_ALGORITHM_AES, 192, flags);
	_tmc_card_add_symmetric_alg(card, SC_ALGORITHM_AES, 256, flags);

	_tmc_card_add_symmetric_alg(card, SC_ALGORITHM_SM1, 128, flags);
	_tmc_card_add_symmetric_alg(card, SC_ALGORITHM_SM1, 256, flags);
	_tmc_card_add_symmetric_alg(card, SC_ALGORITHM_SM4, 128, flags);

	_tmc_card_add_symmetric_alg(card, SC_ALGORITHM_SM2, 256, flags);

	/* RSA */
	flags = 0;
	/* Padding schemes: */
	flags |= SC_ALGORITHM_RSA_PAD_PKCS1|SC_ALGORITHM_RSA_RAW;
	/* Hashes are to be done by the host for RSA */
	flags |= SC_ALGORITHM_RSA_HASH_SHA1|SC_ALGORITHM_RSA_HASH_SHA256;
	/* Key-generation: */
	flags |= SC_ALGORITHM_ONBOARD_KEY_GEN;
	/* Modulus lengths: */
	_tmc_card_add_rsa_alg(card, 512, flags, 0);
	_tmc_card_add_rsa_alg(card, 1024, flags, 0x10001);
	_tmc_card_add_rsa_alg(card, 2048, flags, 0x10001);
	_tmc_card_add_rsa_alg(card, 3072, flags, 0x10001);
	_tmc_card_add_rsa_alg(card, 4096, flags, 0x10001);

	//ecc
	flags = 0;
	flags |= SC_ALGORITHM_ECDSA_RAW;
	flags |= SC_ALGORITHM_ECDSA_HASH_SHA1;
	flags |= SC_ALGORITHM_ONBOARD_KEY_GEN;
	flags |= SC_ALGORITHM_ECDSA_HASH_NONE;

	ext_flags = SC_ALGORITHM_EXT_EC_F_P|
				SC_ALGORITHM_EXT_EC_ECPARAMETERS|
				SC_ALGORITHM_EXT_EC_NAMEDCURVE|
				SC_ALGORITHM_EXT_EC_UNCOMPRESES|
				SC_ALGORITHM_ONBOARD_KEY_GEN;

	_tmc_card_add_ec_alg(card, (256 >> 3), flags, ext_flags, NULL);
//	_tmc_card_add_ec_alg(card, 384, flags, ext_flags, NULL);
//	_tmc_card_add_ec_alg(card, 521, flags, ext_flags, NULL);

	//ecc
	flags = 0;
	flags |= SC_ALGORITHM_SM2_HASH_SM3_256_E;
	flags |= SC_ALGORITHM_SM2_HASH_SM3_256;
	flags |= SC_ALGORITHM_ONBOARD_KEY_GEN;


	ext_flags = SC_ALGORITHM_EXT_EC_F_P|
				SC_ALGORITHM_EXT_EC_ECPARAMETERS|
				SC_ALGORITHM_EXT_EC_NAMEDCURVE|
				SC_ALGORITHM_EXT_EC_UNCOMPRESES|
				SC_ALGORITHM_ONBOARD_KEY_GEN;

	_tmc_card_add_sm2_alg(card, 256, flags, ext_flags, NULL);

	return SC_SUCCESS;

}

static CK_RV tmc_set_le_and_transmit(struct tmc_card *card, struct tmc_apdu *apdu, CK_ULONG olen)
{
	struct tmc_context *ctx = card->ctx;
    CK_ULONG nlen = apdu->sw2 ? (CK_ULONG)apdu->sw2 : 256;
	int rv;

	/* we cannot re-transmit the APDU with the demanded Le value
	* as the buffer is too small => error */
	if (olen < nlen)
		return CKR_BUFFER_TOO_SMALL;

	/* don't try again if it doesn't work this time */
	apdu->flags |= SC_APDU_FLAGS_NO_RETRY_WL;
	/* set the new expected length */
	apdu->resplen = olen;
	apdu->le = nlen;

	/* Belpic V1 applets have a problem: if the card sends a 6C XX (only XX bytes available),
	* and we resend the command too soon (i.e. the reader is too fast), the card doesn't respond.
	* So we build in a delay. */
	//	if (card->type == SC_TYPE_BELPIC_EID)
	//		msleep(40);

	if (card->driver->ops->transmit == NULL)
		return CKR_FUNCTION_NOT_SUPPORTED;

	/* re-transmit the APDU with new Le length */
	rv = card->driver->ops->transmit(ctx, apdu);
	if(rv != SC_SUCCESS) {
		return CKR_FUNCTION_FAILED;
	}
	else {
		return CKR_OK;
	}
}

static CK_RV tmc_transmit_apdu(struct tmc_card *card, tmc_apdu_t *apdu)
{
	CK_RV rv = CKR_OK;
	int r;
	struct tmc_context *ctx = card->ctx;

	if (card->driver->ops->transmit == NULL)
		return CKR_FUNCTION_NOT_SUPPORTED;

	/* send APDU to the reader driver */
	r = card->driver->ops->transmit(ctx, apdu);
	if(r != SC_SUCCESS) {
		return CKR_FUNCTION_FAILED;
	}

	/* ok, the APDU was successfully transmitted. Now we have two special cases:
	* 1. the card returned 0x6Cxx: in this case APDU will be re-transmitted with Le set to SW2
	* (possible only if response buffer size is larger than new Le = SW2)
	*/
	if (apdu->sw1 == 0x6C && (apdu->flags & SC_APDU_FLAGS_NO_RETRY_WL) == 0) {
		rv = tmc_set_le_and_transmit(card, apdu, apdu->sw2);
		if (rv != CKR_OK)
			return rv;
	}

	if (apdu->sw1 == 0x61) {

		apdu->cse = SC_APDU_CASE_2_SHORT;
		apdu->cla = 0x00;
		apdu->ins = 0xC0;
		apdu->p1 = 0x00;
		apdu->p2 = 0x00;

		apdu->le = apdu->sw2;
		apdu->resp = (unsigned char*)apdu->data;
		apdu->resplen = apdu->le;

		if (card->driver->ops->transmit == NULL)
			return CKR_FUNCTION_NOT_SUPPORTED;

		/* re-transmit the APDU with 00C0 cmd */
		rv = card->driver->ops->transmit(ctx, apdu);
		if(rv != SC_SUCCESS) {
			return CKR_FUNCTION_FAILED;
		}
		else {
			return CKR_OK;
		}
	}

	return rv;
}

static const struct tmc_card_error tmcse_errors[] = {
        { 0x6700, CKR_ARGUMENTS_BAD,	"Wrong length" },
        { 0x6982, CKR_USER_NOT_LOGGED_IN, "Security status not satisfied" },
        { 0x6983, CKR_PIN_LOCKED,	"Authentication method blocked" },

        { 0x6A80, CKR_ARGUMENTS_BAD,"Incorrect parameters in the data field" },
        { 0x6A81, CKR_FUNCTION_NOT_SUPPORTED,	"Function not supported" },
        { 0x6A82, CKR_OBJECT_HANDLE_INVALID, "Object handle not invaild" },
        { 0x6A84, CKR_DEVICE_MEMORY,	"Not enough memory space in the file" },
        { 0x6A86, CKR_ARGUMENTS_BAD,"Incorrect parameters P1-P2" },
		{ 0x6A88, CKR_USER_PIN_NOT_INITIALIZED,"User PIN not initialize" },

        { 0x6B00, CKR_ARGUMENTS_BAD,"Wrong parameter(s) P1-P2" },
        { 0x6F00, CKR_GENERAL_ERROR,	"No precise diagnosis" },
};



static CK_RV tmc_check_sw(struct tmc_card *card, unsigned int sw1, unsigned int sw2)
{
	const int err_count = sizeof(tmcse_errors)/sizeof(tmcse_errors[0]);
	int i;

	/* Handle special cases here */
	if(sw1 == 0x6C) {
		return CKR_DATA_LEN_RANGE;
	}
	if((sw1 == 0x90)||(sw1 == 0x95)) {
		return CKR_OK;
	}
	if(sw1 == 0x63U && (sw2 & ~0x0fU) == 0xc0U ) {
		return CKR_PIN_INCORRECT;
	}
	for (i = 0; i < err_count; i++) {
		if(tmcse_errors[i].SWs == ((sw1 << 8) | sw2)) {
			return tmcse_errors[i].errorno;
		}
	}

	return CKR_VENDOR_DEFINED;
}


static CK_RV tmc_select_file_by_fid(struct tmc_card *card, tmc_apdu_t *apdu, u16 fid)
{
	CK_RV rv;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	
	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_selectFile);
	//set fid
	buf[0] = (u8)(fid >> 8);
	buf[1] = (u8)(fid & 0x00FF);

	apdu->lc = 0x02;
	apdu->data = buf;
	apdu->resp = buf;
	apdu->datalen = apdu->lc;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		return rv;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		return rv;
	}

	return rv;	
}

//create alg object
CK_RV tmcse_create_alg(struct tmc_card *card, u16 alg_id)
{
    CK_RV rv;
    tmc_apdu_t *apdu;
    u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};

    if(card == NULL) {
        return CKR_ARGUMENTS_BAD;
    }

    apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
    if(apdu == NULL) {
        return CKR_HOST_MEMORY;
    }

    tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_createFile);

    apdu->p1 = 0x06;//create alg object

    //set alg id
    buf[0] = (u8)(alg_id >> 8);
    buf[1] = (u8)(alg_id & 0x00FF);

    apdu->lc = 0x02;
    apdu->data = buf;
    apdu->datalen = apdu->lc;

    rv = tmc_transmit_apdu(card, apdu);
    if (rv != CKR_OK) {
        goto out;
    }

    rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
    if (rv != CKR_OK) {
        goto out;
    }

    out:
    free(apdu);
    return rv;
}

//file operation
CK_RV tmcse_create_df(struct tmc_card *card, u16 fid, u8 *aid, CK_ULONG length)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};

	if((card == NULL) || (aid == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if(length > SC_MAX_AID_SIZE) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_createFile);

	apdu->p1 = 0x00;//create MF

	//set fid
	buf[0] = (u8)(fid >> 8);
	buf[1] = (u8)(fid & 0x00FF);

	//create child df AC
	buf[2] = (u8)0x80;//free

	//create ef AC
	buf[4] = (u8)0x80;//free

	//set delete AC
	buf[5] = (u8)SOPIN;

	//set AID
	buf[8] = (u8)length;
	memset(buf+9, 0xFF, SC_MAX_AID_SIZE);
	memcpy(buf+9, aid, length);

	//set DF FileType
	buf[25] = 0x00; //normal MF

	apdu->lc = 0x1C;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_create_pin(struct tmc_card *card, u16 fid)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};

	if(card == NULL) {
		return CKR_ARGUMENTS_BAD;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_createFile);

	apdu->p1 = 0x04;//create keyFile

	//set fid
	buf[0] = (u8)(fid >> 8);
	buf[1] = (u8)(fid & 0x00FF);

	//read AC
	buf[2] = (u8)0x40;//forbidden

	//write AC
	buf[3] = (u8)SOPIN;//SO PIN

	//set EF FileType
	buf[8] = 0x12;

	//set EF Size
	buf[9] = 0x02;
	buf[10] = 0x27;

	apdu->lc = 0x14;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_create_bin(struct tmc_card *card, u16 fid, CK_ULONG size)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};

	if(card == NULL) {
		return CKR_ARGUMENTS_BAD;
	}

	if(size > SC_MAX_LENGTH_SIZE) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_createFile);

	apdu->p1 = 0x03;//create EF

	//set fid
	buf[0] = (u8)(fid >> 8);
	buf[1] = (u8)(fid & 0x00FF);

	//read AC
	buf[2] = (u8)0x80;//free

	//write AC
	buf[3] = (u8)0x80;//free

	//delete AC
	buf[4] = (u8)0x40;//forbidden

	//set Attribute
	buf[6] = 0xFF;

	//SFI
	buf[7] = 0x81;

	//set EF FileType
	buf[8] = 0x01;//binary file

	//set EF Size
	buf[9] = (u8)(size >> 8);
	buf[10] = (u8)(size & 0x00FF);

	apdu->lc = 0x14;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_create_object(struct tmc_card *card, u16 fid, u8 objtype, u8 ac, CK_ULONG attr_size, CK_ULONG data_size)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};

	if((card == NULL)
	||(objtype > CKO_SECRET_KEY)
	||(ac > PRIVATE_OBJECT)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((attr_size > SC_MAX_LENGTH_SIZE) || (data_size > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_createFile);

	apdu->p1 = 0x05;//create objectFile

	//set fid
	buf[0] = (u8)(fid >> 8);
	buf[1] = (u8)(fid & 0x00FF);

	//set ObjectType
	buf[2] = (u8)((objtype << 4) | 0x85);

	//set Attribute Read AC
	buf[3] = (u8)0x80;//free

	//set Attribute Modify AC
	if(ac != 0x00) {//private object
		buf[4] = (u8)UserPIN;
	}
	else {
		buf[4] = (u8)0x80;//free
	}

	//set Attribute Size
	buf[5] = (u8)(attr_size >> 8);
	buf[6] = (u8)(attr_size & 0x00FF);

	//set Data Read AC
	if(ac != 0x00) {//private object
		buf[7] = (u8)UserPIN;
	}
	else {
		buf[7] = (u8)0x80;//free
	}
	if((objtype == CKO_PRIVATE_KEY)||(objtype == CKO_SECRET_KEY)) {
		buf[7] = (u8)0x40;//forbidden
	}
	
	//set Data Modify AC
	if(ac != 0x00) {//private object
		buf[8] = (u8)UserPIN;
	}
	else {
		buf[8] = (u8)0x80;//free
	}
	
	//set Data Opera AC
	if(ac != 0x00) {//private object
		buf[9] = (u8)UserPIN;
	}
	else {
		buf[9] = (u8)0x80;//free
	}

	//set Data Size
	buf[10] = (u8)(data_size >> 8);
	buf[11] = (u8)(data_size & 0x00FF);

	//set Delete AC
	if(ac != 0x00) {//private object
		buf[12] = (u8)UserPIN;
	}
	else {
		buf[12] = (u8)0x80;//free
	}

	apdu->lc = 0x14;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_delete_file(struct tmc_card *card, u16 fid)
{
	CK_RV rv;
	tmc_apdu_t *apdu;

	if(card == NULL) {
		return CKR_ARGUMENTS_BAD;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	if(fid != 0x3F00) {
		rv = tmc_select_file_by_fid(card, apdu, fid);
		if (rv != CKR_OK) {
			goto out;
		}
	}

	//delete File
	tmc_format_apdu(apdu, SC_APDU_CASE_1, apdu_deleteFile);

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_select_fid(struct tmc_card *card, u16 fid)
{
	CK_RV rv;
	tmc_apdu_t *apdu;

	if(card == NULL) {
		return CKR_ARGUMENTS_BAD;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	rv = tmc_select_file_by_fid(card, apdu, fid);
	if (rv != CKR_OK) {
		goto out;
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_select_file(struct tmc_card *card, u8 *aid, CK_ULONG length, u8 *resp, CK_ULONG *resp_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};

	if((card == NULL)
	||(aid == NULL)
	||(resp_len == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if(length > SC_MAX_AID_SIZE) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_selectFile);

	apdu->p1 = 0x04;

	//set aid
	memcpy(buf, aid, length);

	apdu->lc = (u8)length;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	apdu->le = 0;
	apdu->resp = buf;
	apdu->resplen = apdu->le;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	if(apdu->resplen != 0x00) {
		if(resp != NULL) {
			if(apdu->resplen > (unsigned int)(*resp_len)) {
				rv = CKR_BUFFER_TOO_SMALL;
				goto out;
			}
			memcpy(resp, apdu->resp, apdu->resplen);
		}
	}
	*resp_len = apdu->resplen;

	out:
	free(apdu);
	return rv;
}


CK_RV tmcse_select_MF(struct tmc_card *card)
{
	CK_RV rv;
    struct tmc_apdu *apdu;


	if(card == NULL) {
		return CKR_ARGUMENTS_BAD;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(struct tmc_apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	rv = tmc_select_file_by_fid(card, apdu, 0x3F00);
	if (rv != CKR_OK) {
		goto out;
	}



	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_write_pin(struct tmc_card *card, CK_ULONG pintype, u8 trylimit, u8 *pin, CK_ULONG length)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	SHA256Context sha256ctx;

	if((card == NULL) || (pin == NULL)
	||((trylimit > 0x0F) || (trylimit == 0x00))) {
		return CKR_ARGUMENTS_BAD;
	}

	if(pintype >= CKU_CONTEXT_SPECIFIC) {
		return CKR_USER_TYPE_INVALID;
	}

	if((length == 0)||(length > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_writeKey);

	//KeyType
	buf[0] = 0x00;

	//KeyIndex
	if(pintype == CKU_SO) {
		buf[1] = SOPIN;
	}
	else if(pintype == CKU_USER) {
		buf[1] = UserPIN;
	}

	//try limit & remain try limit
	buf[4] = (u8)((trylimit << 4) | (trylimit));

	//modify right
	if(pintype == CKU_SO) {
		buf[5] = (u8)(0x00 | SOPIN); // == SOPIN
	}
	else if(pintype == CKU_USER) {
		buf[5] = (u8)(0x80 | UserPIN);// >= UserPIN
	}

	//ac
	if(pintype == CKU_SO) {
		buf[6] = SOPIN;
	}
	else if(pintype == CKU_USER) {
		buf[6] = UserPIN;
	}

	//set PIN
	SHA256Init(&sha256ctx);
	SHA256Update(&sha256ctx, pin, length);
	SHA256Final(&sha256ctx, buf+7, SC_MAX_PIN_SIZE);

	apdu->lc = 0x27;
	apdu->data = buf;
	apdu->datalen = apdu->lc;	

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_read_binary(struct tmc_card *card, u16 fid, CK_ULONG offset, CK_ULONG length, u8 *bin)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len;
	CK_ULONG i=0,resp_len=0;

	if((card == NULL) || (bin == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((offset > SC_MAX_LENGTH_SIZE) || (length == 0x00) || (length > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	rv = tmc_select_file_by_fid(card, apdu, fid);
	if (rv != CKR_OK) {
		goto out;
	}

	for(i=0; i<length; i+=len) {
		
		len = (u8)(((length-i) > SC_MAX_SEND_BUFF_CFG_SIZE) ? (SC_MAX_SEND_BUFF_CFG_SIZE) : (length-i));

		tmc_format_apdu(apdu, SC_APDU_CASE_2_SHORT, apdu_readBin);

		apdu->p1 = (u8)((offset+i) >> 8);
		apdu->p2 = (u8)((offset+i) & 0x00FF);
		
		apdu->le = len;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			memcpy(bin+i, apdu->resp, apdu->resplen);
			resp_len += apdu->resplen;
		}
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_update_binary(struct tmc_card *card, u16 fid, CK_ULONG offset, u8 *bin, CK_ULONG length)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len;
	CK_ULONG i;

	if((card == NULL) || (bin == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((offset > SC_MAX_LENGTH_SIZE) || (length == 0x00) || (length > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	rv = tmc_select_file_by_fid(card, apdu, fid);
	if (rv != CKR_OK) {
		goto out;
	}

	for(i=0; i<length; i+=len) {
		
		len = (u8)(((length-i) > SC_MAX_SEND_BUFF_CFG_SIZE) ? (SC_MAX_SEND_BUFF_CFG_SIZE) : (length-i));

		tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_updateBin);

		apdu->p1 = (u8)((offset+i) >> 8);
		apdu->p2 = (u8)((offset+i) & 0x00FF);

		memcpy(buf, bin+i, len);

		apdu->lc = len;
		apdu->data = buf;
		apdu->datalen = apdu->lc;
		
		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_read_binary_by_sfi(struct tmc_card *card, u8 sfi, CK_ULONG offset, CK_ULONG length, u8 *bin)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len;
	CK_ULONG i=0,resp_len=0;

	if((card == NULL) || (bin == NULL) || (sfi == 0 || sfi > 31)) {
		return CKR_ARGUMENTS_BAD;
	}

	if(((offset + length) > SC_MAX_LENGTH_SIZE_SFI) || (length == 0x00)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	for(i=0; i<length; i+=len) {
		
		len = (u8)(((length-i) > SC_MAX_SEND_BUFF_CFG_SIZE) ? (SC_MAX_SEND_BUFF_CFG_SIZE) : (length-i));

		tmc_format_apdu(apdu, SC_APDU_CASE_2_SHORT, apdu_readBin);

		apdu->p1 = (u8)(0x80|sfi);
		apdu->p2 = (u8)((offset+i) & 0x00FF);
		
		apdu->le = len;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			memcpy(bin+i, apdu->resp, apdu->resplen);
			resp_len += apdu->resplen;
		}
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_update_binary_by_sfi(struct tmc_card *card, u8 sfi, CK_ULONG offset, u8 *bin, CK_ULONG length)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len;
	CK_ULONG i;

	if((card == NULL) || (bin == NULL) || (sfi == 0 || sfi > 31)) {
		return CKR_ARGUMENTS_BAD;
	}

	if(((offset + length) > SC_MAX_LENGTH_SIZE_SFI) || (length == 0x00)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	for(i=0; i<length; i+=len) {
		
		len = (u8)(((length-i) > SC_MAX_SEND_BUFF_CFG_SIZE) ? (SC_MAX_SEND_BUFF_CFG_SIZE) : (length-i));

		tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_updateBin);

		apdu->p1 = (u8)(0x80|sfi);
		apdu->p2 = (u8)((offset+i) & 0x00FF);

		memcpy(buf, bin+i, len);

		apdu->lc = len;
		apdu->data = buf;
		apdu->datalen = apdu->lc;
		
		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_read_object(struct tmc_card *card, u16 fid, u8 zone, u8 *value, CK_ULONG *length)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len;
	CK_ULONG i=0,resp_len;

	if((card == NULL) || (length == NULL) || (zone > VALUE_ZONE)) {
		return CKR_ARGUMENTS_BAD;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	rv = tmc_select_file_by_fid(card, apdu, fid);
	if (rv != CKR_OK) {
		goto out;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_2_SHORT, apdu_readObject);
	if(zone == VALUE_ZONE) {
		apdu->p1 |= (u8)0x80;
	}
	apdu->le = 0x00;
	apdu->resp = buf;
	apdu->resplen = apdu->le;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	if(apdu->resplen != 0x00) {
		if(value != NULL) {
			memcpy(value+i, apdu->resp, apdu->resplen);
		}
		i += apdu->resplen;
	}

	while(apdu->sw1 == 0x95) {
	
		tmc_format_apdu(apdu, SC_APDU_CASE_2_SHORT, apdu_readObject);
		if(zone == VALUE_ZONE) {
			apdu->p1 |= (u8)0x80;
		}
		apdu->p1 |= (u8)(i >> 8);
		apdu->p2 |= (u8)(i & 0xFF);

		apdu->le = apdu->sw2;
		apdu->resp = buf;
		apdu->resplen = apdu->le;
		
		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			if(value != NULL) {
				memcpy(value+i, apdu->resp, apdu->resplen);
			}
			i += apdu->resplen;
		}
	}

	*length = i;

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_update_object(struct tmc_card *card, u16 fid, u8 zone, CK_ULONG offset, CK_ULONG length, u8 *value)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len;
	CK_ULONG i;

	if((card == NULL) || (value == NULL) || (zone > VALUE_ZONE)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((offset > SC_MAX_LENGTH_SIZE) || (length == 0x00) || (length > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	rv = tmc_select_file_by_fid(card, apdu, fid);
	if (rv != CKR_OK) {
		goto out;
	}

	for(i=0; i<length; i+=len) {
		
		len = (u8)(((length-i) > SC_MAX_SEND_BUFF_CFG_SIZE) ? (SC_MAX_SEND_BUFF_CFG_SIZE) : (length-i));

		tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_updateObject);

		apdu->p1 = (u8)((offset+i) >> 8);
		if(zone == VALUE_ZONE) {
			apdu->p1 |= (u8)0x80;
		}

		apdu->p2 = (u8)((offset+i) & 0x00FF);

		memcpy(buf, value+i, len);

		apdu->lc = len;
		apdu->data = buf;
		apdu->datalen = apdu->lc;
		
		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_end_personal(struct tmc_card *card)
{
	CK_RV rv;
	tmc_apdu_t *apdu;

	if(card == NULL) {
		return CKR_ARGUMENTS_BAD;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_1, apdu_endPersonal);

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	out:
	free(apdu);
	return rv;
}


//pin operation
CK_RV tmcse_verify_pin(struct tmc_card *card, CK_ULONG pintype, u8 *pin, CK_ULONG length)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	SHA256Context sha256ctx;

	if((card == NULL) || (pin == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if(pintype >= CKU_CONTEXT_SPECIFIC) {
		return CKR_USER_TYPE_INVALID;
	}

	if((length == 0) || (length > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_verifyPIN);

	if(pintype == CKU_SO) {
		apdu->p2 = SOPIN;
	}
	else if(pintype == CKU_USER) {
		apdu->p2 = UserPIN;
	}
	else {
		return CKR_USER_TYPE_INVALID;
	}

	//set pin
	SHA256Init(&sha256ctx);
	SHA256Update(&sha256ctx, pin, length);
	SHA256Final(&sha256ctx, buf, SC_MAX_PIN_SIZE);

	apdu->lc = (u8)SC_MAX_PIN_SIZE;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_change_pin(struct tmc_card *card, CK_ULONG pintype, u8 *pin, CK_ULONG length)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	SHA256Context sha256ctx;

	if((card == NULL) || (pin == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if(pintype >= CKU_CONTEXT_SPECIFIC) {
		return CKR_USER_TYPE_INVALID;
	}

	if((length == 0) || (length > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_changePIN);

	if(pintype == CKU_SO) {
		apdu->p2 = SOPIN;
	}
	else if(pintype == CKU_USER) {
		apdu->p2 = UserPIN;
	}
	else {
		return CKR_USER_TYPE_INVALID;
	}

	//set pin
	SHA256Init(&sha256ctx);
	SHA256Update(&sha256ctx, pin, length);
	SHA256Final(&sha256ctx, buf, SC_MAX_PIN_SIZE);

	apdu->lc = (u8)SC_MAX_PIN_SIZE;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_verify_tk(struct tmc_card *card, u8 *pin, CK_ULONG length)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	SHA256Context sha256ctx;

	if((card == NULL) || (pin == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((length == 0) || (length > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_verifyTK);

	//set pin
	SHA256Init(&sha256ctx);
	SHA256Update(&sha256ctx, pin, length);
	SHA256Final(&sha256ctx, buf, SC_MAX_PIN_SIZE);

	apdu->lc = (u8)SC_MAX_PIN_SIZE;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_change_tk(struct tmc_card *card, u8 *pin, CK_ULONG length)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	SHA256Context sha256ctx;

	if((card == NULL) || (pin == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((length == 0) || (length > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_changeTK);

	//set pin
	SHA256Init(&sha256ctx);
	SHA256Update(&sha256ctx, pin, length);
	SHA256Final(&sha256ctx, buf, SC_MAX_PIN_SIZE);

	apdu->lc = (u8)SC_MAX_PIN_SIZE;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	out:
	free(apdu);
	return rv;
}



CK_RV tmcse_get_pin_info(struct tmc_card *card, CK_ULONG pintype, struct tmcse_pin_info *info)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};

	if((card == NULL) || (info == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if(pintype >= CKU_CONTEXT_SPECIFIC) {
		return CKR_USER_TYPE_INVALID;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_2_SHORT, apdu_getInfo);

	if(pintype == CKU_SO) {
		apdu->p2 = SOPIN;
	}
	else if(pintype == CKU_USER) {
		apdu->p2 = UserPIN;
	}
	else {
		return CKR_USER_TYPE_INVALID;
	}
	
	apdu->le = 0x02;
	apdu->resp = buf;
	apdu->resplen = apdu->le;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	if(apdu->resplen != 0x00) {
		info->maxTryCounter = (apdu->resp[0] >> 4);
		info->curTryCounter = (apdu->resp[0] & 0x0F);
		info->isDefault = (apdu->resp[1] == 0x00) ? 1 : 0;
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_clear_pin_state(struct tmc_card *card)
{
	CK_RV rv;
	tmc_apdu_t *apdu;

	if(card == NULL) {
		return CKR_ARGUMENTS_BAD;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_1, apdu_clearSecurityState);

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	out:
	free(apdu);
	return rv;
}


//key operation
CK_RV tmcse_generate_key(struct tmc_card *card, CK_ULONG mechanism, CK_ULONG bitlengh, u16 fid)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 alg=0;

	if(card == NULL) {
		return CKR_ARGUMENTS_BAD;
	}

	switch(mechanism) {
		case CKM_DES_KEY_GEN:
		case CKM_DES2_KEY_GEN:
		case CKM_DES3_KEY_GEN:
			alg = 0x00;
			break;
		case CKM_AES_KEY_GEN:
			alg = 0x01;
			break;
		case CKM_SM1_128_KEY_GEN:
		case CKM_SM1_256_KEY_GEN:
			alg = 0x02;
			break;
		case CKM_SM4_128_KEY_GEN:
			alg = 0x03;
			break;
		default:
			return CKR_MECHANISM_INVALID;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_generateKey);

	buf[0] = (u8)0x00;//Token sym-key
	buf[1] = (u8)alg;
	//set fid
	buf[2] = (u8)(fid >> 8);
	buf[3] = (u8)(fid & 0x00FF);
	//set bit-length
	buf[4] = (u8)(bitlengh >> 8);
	buf[5] = (u8)(bitlengh & 0x00FF);

	apdu->lc = 0x06;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_generate_key_ex(struct tmc_card *card, CK_ULONG mechanism, CK_ULONG bitlengh, u8 *key, CK_ULONG *key_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 alg=0;

	if(card == NULL) {
		return CKR_ARGUMENTS_BAD;
	}

	switch(mechanism) {
		case CKM_DES_KEY_GEN:
		case CKM_DES2_KEY_GEN:
		case CKM_DES3_KEY_GEN:
			alg = 0x00;
			break;
		case CKM_AES_KEY_GEN:
			alg = 0x01;
			break;
		case CKM_SM1_128_KEY_GEN:
		case CKM_SM1_256_KEY_GEN:
			alg = 0x02;
			break;
		case CKM_SM4_128_KEY_GEN:
			alg = 0x03;
			break;
		default:
			return CKR_MECHANISM_INVALID;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_generateKey);

	buf[0] = (u8)0x10;//Session sym-key
	buf[1] = (u8)alg;
	//set bit-length
	buf[2] = (u8)(bitlengh >> 8);
	buf[3] = (u8)(bitlengh & 0x00FF);

	apdu->lc = 0x04;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	apdu->le = 0x00;
	apdu->resp = buf;
	apdu->resplen = apdu->le;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	if(key != NULL) {
		if(apdu->resplen > (unsigned int)(*key_len)) {
			rv = CKR_BUFFER_TOO_SMALL;
			goto out;
		}
		memcpy(key, apdu->resp, apdu->resplen);
	}
	*key_len = apdu->resplen;
	
	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_generate_keypair(struct tmc_card *card, CK_ULONG mechanism, CK_ULONG bitlengh, CK_ULONG keytype, u8* param, CK_ULONG param_len, u16 pub_fid, u16 pri_fid)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 alg=0xff;
	CK_ULONG dataLen=0,len=0,off=0;

	if(card == NULL) {
		return CKR_ARGUMENTS_BAD;
	}

	switch(mechanism) {

		case CKM_RSA_PKCS_KEY_PAIR_GEN:
			if(keytype == RSA_KEY_TYPE_ND) {
				alg = 0x04;
			}
			else if(keytype == RSA_KEY_TYPE_CRT) {
				alg = 0x05;
			}
			else {
				return CKR_ARGUMENTS_BAD;
			}
			break;
		case CKM_EC_KEY_PAIR_GEN:
			if(param == NULL) {
				return CKR_ARGUMENTS_BAD;
			}
			alg = 0x06;
			break;
		case CKM_SM2_KEY_PAIR_GEN:
			alg = 0x07;
			break;
		case CKM_DH_PKCS_PARAMETER_GEN:
		default:
			return CKR_MECHANISM_INVALID;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_generateKey);

	apduBuf[dataLen++] = 0x01;//Token & Asym
	apduBuf[dataLen++] = alg;
	//set public fid
	apduBuf[dataLen++] = (u8)(pub_fid >> 8);
	apduBuf[dataLen++] = (u8)(pub_fid & 0x00FF);
	//set private fid
	apduBuf[dataLen++] = (u8)(pri_fid >> 8);
	apduBuf[dataLen++] = (u8)(pri_fid & 0x00FF);
	//set alg bit length
	apduBuf[dataLen++] = (u8)(bitlengh >> 8);
	apduBuf[dataLen++] = (u8)(bitlengh & 0x00FF);
	if(mechanism == CKM_EC_KEY_PAIR_GEN) {
		memcpy(apduBuf+dataLen, param, param_len);
		dataLen += param_len;
	}
	else if(mechanism == CKM_RSA_PKCS_KEY_PAIR_GEN){
		apduBuf[dataLen++] = 0x00;
		apduBuf[dataLen++] = 0x00;
		apduBuf[dataLen++] = 0x00;
		apduBuf[dataLen++] = 0x00;
		apduBuf[dataLen++] = 0x00;
	}

	if (dataLen <= SC_MAX_SEND_BUFF_CFG_SIZE) {
		apdu->p1 = 0x00;//unique block
		memcpy(buf, apduBuf, dataLen);

		apdu->lc = dataLen;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}
	else {
	
		while (off < dataLen) {

			if ((dataLen - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
				len = SC_MAX_SEND_BUFF_CFG_SIZE;
				if (off == 0x00) {
					apdu->p1 = 0x01;//first block
				} else {
					apdu->p1 = 0x02;//mid block
				}
			} else {
				len = (dataLen - off);
				apdu->p1 = 0x03;//last block
			}

			memcpy(buf, apduBuf+off, len);
			off += len;

			apdu->lc = len;
			apdu->data = buf;
			apdu->datalen = apdu->lc;

			rv = tmc_transmit_apdu(card, apdu);
			if (rv != CKR_OK) {
				goto out;
			}

			rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
			if (rv != CKR_OK) {
				goto out;
			}
		}
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_generate_keypair_ex(struct tmc_card *card, CK_ULONG mechanism, CK_ULONG bitlengh, CK_ULONG keytype, u8* param, CK_ULONG param_len, u8 *pubkey, CK_ULONG *pubkey_len, u8 *prikey, CK_ULONG *prikey_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 alg=0;
	CK_ULONG i=0,dataLen=0,len=0,off=0;

	if((card == NULL)||(pubkey_len == NULL)||(prikey_len == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	switch(mechanism) {

		case CKM_RSA_PKCS_KEY_PAIR_GEN:
			if(keytype == RSA_KEY_TYPE_ND) {
				alg = 0x04;
			}
			else if(keytype == RSA_KEY_TYPE_CRT) {
				alg = 0x05;
			}
			else {
				return CKR_ARGUMENTS_BAD;
			}
			break;
		case CKM_EC_KEY_PAIR_GEN:
			if(param == NULL) {
				return CKR_ARGUMENTS_BAD;
			}
			alg = 0x06;
			break;
		case CKM_SM2_KEY_PAIR_GEN:
			alg = 0x07;
			break;
		case CKM_DH_PKCS_PARAMETER_GEN:			
		default:
			return CKR_MECHANISM_INVALID;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_generateKey);

	apduBuf[dataLen++] = 0x11;//Session & Asym
	apduBuf[dataLen++] = alg;
	//set alg bit length
	apduBuf[dataLen++] = (u8)(bitlengh >> 8);
	apduBuf[dataLen++] = (u8)(bitlengh & 0x00FF);
	if(mechanism == CKM_EC_KEY_PAIR_GEN) {
		memcpy(apduBuf+dataLen, param, param_len);
		dataLen += param_len;
	}
	else {
		apduBuf[dataLen++] = 0x00;
		apduBuf[dataLen++] = 0x00;
		apduBuf[dataLen++] = 0x00;
		apduBuf[dataLen++] = 0x00;
		apduBuf[dataLen++] = 0x00;
	}
	
	if (dataLen <= SC_MAX_SEND_BUFF_CFG_SIZE) {
		apdu->p1 = 0x00;//unique block
		memcpy(buf, apduBuf, dataLen);

		apdu->lc = dataLen;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		apdu->le = 0x00;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}
	else {
	
		while (off < dataLen) {

			if ((dataLen - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
				len = SC_MAX_SEND_BUFF_CFG_SIZE;
				if (off == 0x00) {
					apdu->p1 = 0x01;//first block
				} else {
					apdu->p1 = 0x02;//mid block
				}
			} else {
				len = (dataLen - off);
				apdu->p1 = 0x03;//last block
			}

			memcpy(buf, apduBuf+off, len);
			off += len;

			apdu->lc = len;
			apdu->data = buf;
			apdu->datalen = apdu->lc;

			apdu->le = 0x00;
			apdu->resp = buf;
			apdu->resplen = apdu->le;

			rv = tmc_transmit_apdu(card, apdu);
			if (rv != CKR_OK) {
				goto out;
			}

			rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
			if (rv != CKR_OK) {
				goto out;
			}
		}
	}

	if(apdu->resplen != 0x00) {
		memcpy(apduBuf+i, apdu->resp, apdu->resplen);
		i += apdu->resplen;
	}

	while(apdu->sw1 == 0x95) {
	
		tmc_format_apdu(apdu, SC_APDU_CASE_2_SHORT, apdu_getRespData);

		apdu->le = apdu->sw2;
		apdu->resp = buf;
		apdu->resplen = apdu->le;
		
		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			memcpy(apduBuf+i, apdu->resp, apdu->resplen);
			i += apdu->resplen;
		}
	}

	len = (CK_ULONG)((apduBuf[0] << 8) | apduBuf[1]);
	if(pubkey != NULL) {
		if((unsigned int)len > (unsigned int)(*pubkey_len)) {
			rv = CKR_BUFFER_TOO_SMALL;
			goto out;
		}
		memcpy(pubkey, apduBuf+2, len);// RSA : N+e    SM2/ECC : PublicKey
	}
	*pubkey_len = len;
	
	i = 2+len;
	len = (CK_ULONG)((apduBuf[i] << 8) | apduBuf[i+1]);
	if(prikey != NULL) {
		if((unsigned int)len > (unsigned int)(*prikey_len)) {
			rv = CKR_BUFFER_TOO_SMALL;
			goto out;
		}
		memcpy(prikey, apduBuf+i+2, len);// RSA : N+D    SM2/ECC : PrivateKey
	}
	*prikey_len = len;

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_import_key(struct tmc_card *card, CK_ULONG algtype, u8 *key, CK_ULONG key_len, u16 fid)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len=0,alg=0;
	CK_ULONG off=0;

	if((card == NULL) || (key == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	switch(algtype) {
		case CKK_AES:
			alg = 0x01;
			break;
		case CKK_DES:
		case CKK_DES2:
		case CKK_DES3:
			alg = 0x00;
			break;
		case CKK_SM1:
			alg = 0x02;
			break;
		case CKK_SM4:
			alg = 0x03;
			break;
		default:
			return CKR_ARGUMENTS_BAD;
	}

	if((key_len > SC_MAX_LENGTH_SIZE) || (key_len == 0x00)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_importKey);

	buf[off++] = 0x00;//Token & Key
	
	buf[off++] = alg;

	//set fid
	buf[off++] = (u8)(fid >> 8);
	buf[off++] = (u8)(fid & 0x00FF);

	//set key len
	buf[off++] = (u8)(key_len >> 8);
	buf[off++] = (u8)(key_len & 0x00FF);

	if(key_len > (SC_MAX_SEND_BUFF_CFG_SIZE - off)) {
		len = (SC_MAX_SEND_BUFF_CFG_SIZE - off);
		apdu->p1 = 0x01;//first block
	}
	else {
		len = key_len;
		apdu->p1 = 0x00;//unique block
	}

	memcpy(buf+off, key, len);//key value

	apdu->lc = off+len;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	off = 0;
	while((off+len) < key_len) {
		
		tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_importKey);

		off += len;

		if((key_len - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
			len = SC_MAX_SEND_BUFF_CFG_SIZE;
			apdu->p1 = 0x02;//mid block
		}
		else {
			len = (key_len - off);
			apdu->p1 = 0x03;//last block
		}

		memcpy(buf, key+off, len);//key value

		apdu->lc = len;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_import_pubkey(struct tmc_card *card, CK_ULONG algtype, u8* param, CK_ULONG param_len, u8 *key, CK_ULONG key_len, u16 fid)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 alg=0;
	CK_ULONG dataLen=0,len=0,off=0;

	if((card == NULL) || (key == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	switch(algtype) {
		case CKK_RSA:
			alg = 0x04;
			break;
		case CKK_EC:
			if(param == NULL) {
				return CKR_ARGUMENTS_BAD;
			}
			alg = 0x06;
			break;
		case CKK_SM2:
			alg = 0x07;
			break;
		case CKK_DH:
			if(param == NULL) {
				return CKR_ARGUMENTS_BAD;
			}
			alg = 0x08;
			break;
		default:
			return CKR_ARGUMENTS_BAD;
	}

	if((key_len > SC_MAX_LENGTH_SIZE) || (key_len == 0x00)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_importKey);

	apduBuf[dataLen++] = 0x01;//Token & PublicKey
	apduBuf[dataLen++] = alg;

	//set fid
	apduBuf[dataLen++] = (u8)(fid >> 8);
	apduBuf[dataLen++] = (u8)(fid & 0x00FF);

	//set pubkey
	apduBuf[dataLen++] = (u8)(key_len >> 8);
	apduBuf[dataLen++] = (u8)(key_len & 0x00FF);
	memcpy(apduBuf+dataLen, key, key_len);//key value
	dataLen += key_len;
	if((algtype == CKK_EC)||(algtype == CKK_DH)) {
		memcpy(apduBuf+dataLen, param, param_len);
		dataLen += param_len;
	}
	
	if (dataLen <= SC_MAX_SEND_BUFF_CFG_SIZE) {
		apdu->p1 = 0x00;//unique block
		memcpy(buf, apduBuf, dataLen);

		apdu->lc = dataLen;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}
	else {
	
		while (off < dataLen) {

			if ((dataLen - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
				len = SC_MAX_SEND_BUFF_CFG_SIZE;
				if (off == 0x00) {
					apdu->p1 = 0x01;//first block
				} else {
					apdu->p1 = 0x02;//mid block
				}
			} else {
				len = (dataLen - off);
				apdu->p1 = 0x03;//last block
			}

			memcpy(buf, apduBuf+off, len);
			off += len;

			apdu->lc = len;
			apdu->data = buf;
			apdu->datalen = apdu->lc;

			rv = tmc_transmit_apdu(card, apdu);
			if (rv != CKR_OK) {
				goto out;
			}

			rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
			if (rv != CKR_OK) {
				goto out;
			}
		}
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_import_prikey(struct tmc_card *card, CK_ULONG algtype, CK_ULONG keytype, u8* param, CK_ULONG param_len, u8 *key, CK_ULONG key_len, u16 fid)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 alg=0;
	CK_ULONG dataLen=0,len=0,off=0;

	if((card == NULL) || (key == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	switch(algtype) {
		case CKK_RSA:
			if(keytype == RSA_KEY_TYPE_ND) {
				alg = 0x04;
			}
			else if(keytype == RSA_KEY_TYPE_CRT) {
				alg = 0x05;
			}
			else {
				return CKR_ARGUMENTS_BAD;
			}
			break;
		case CKK_EC:
			if(param == NULL) {
				return CKR_ARGUMENTS_BAD;
			}
			alg = 0x06;
			break;
		case CKK_SM2:
			alg = 0x07;
			break;
		case CKK_DH:
			if(param == NULL) {
				return CKR_ARGUMENTS_BAD;
			}
			alg = 0x08;
			break;
		default:
			return CKR_ARGUMENTS_BAD;
	}

	if((key_len > SC_MAX_LENGTH_SIZE) || (key_len == 0x00)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_importKey);

	apduBuf[dataLen++] = 0x02;//Token & PrivaterKey
	apduBuf[dataLen++] = alg;

	//set fid
	apduBuf[dataLen++] = (u8)(fid >> 8);
	apduBuf[dataLen++] = (u8)(fid & 0x00FF);

	//set prikey
	apduBuf[dataLen++] = (u8)(key_len >> 8);
	apduBuf[dataLen++] = (u8)(key_len & 0x00FF);
	memcpy(apduBuf+dataLen, key, key_len);//key value
	dataLen += key_len;
	if((algtype == CKK_EC)||(algtype == CKK_DH)) {
		memcpy(apduBuf+dataLen, param, param_len);
		dataLen += param_len;
	}
	
	if (dataLen <= SC_MAX_SEND_BUFF_CFG_SIZE) {
		apdu->p1 = 0x00;//unique block
		memcpy(buf, apduBuf, dataLen);

		apdu->lc = dataLen;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}
	else {
	
		while (off < dataLen) {

			if ((dataLen - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
				len = SC_MAX_SEND_BUFF_CFG_SIZE;
				if (off == 0x00) {
					apdu->p1 = 0x01;//first block
				} else {
					apdu->p1 = 0x02;//mid block
				}
			} else {
				len = (dataLen - off);
				apdu->p1 = 0x03;//last block
			}

			memcpy(buf, apduBuf+off, len);
			off += len;

			apdu->lc = len;
			apdu->data = buf;
			apdu->datalen = apdu->lc;

			rv = tmc_transmit_apdu(card, apdu);
			if (rv != CKR_OK) {
				goto out;
			}

			rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
			if (rv != CKR_OK) {
				goto out;
			}
		}
	}
	
	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_enc_key(struct tmc_card *card, u8 *key, CK_ULONG key_len, u8 *cipherkey, CK_ULONG *cipherkey_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len=0;
	CK_ULONG clen=0,off=0;

	if((card == NULL) || (key == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((key_len > SC_MAX_LENGTH_SIZE) || (key_len == 0x00)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_importKey);

	buf[off++] = 0x10;//Session & RFU

	buf[off++] = 0x00;//RFU

	//set key len
	buf[off++] = (u8)(key_len >> 8);
	buf[off++] = (u8)(key_len & 0x00FF);

	if(key_len > (SC_MAX_SEND_BUFF_CFG_SIZE - off)) {
		len = (SC_MAX_SEND_BUFF_CFG_SIZE - off);
		apdu->p1 = 0x01;//first block
	}
	else {
		len = key_len;
		apdu->p1 = 0x00;//unique block
	}

	memcpy(buf+off, key, len);//key value

	apdu->lc = off+len;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	apdu->le = 0;
	apdu->resp = buf;
	apdu->resplen = apdu->le;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	off = 0;
	while((off+len) < key_len) {
		
		tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_importKey);

		off += len;

		if((key_len - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
			len = SC_MAX_SEND_BUFF_CFG_SIZE;
			apdu->p1 = 0x02;//mid block
		}
		else {
			len = (key_len - off);
			apdu->p1 = 0x03;//last block
		}

		memcpy(buf, key+off, len);//key value

		apdu->lc = len;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		apdu->le = 0;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}
	}


	if(apdu->resplen != 0x00) {
		memcpy(apduBuf+clen, apdu->resp, apdu->resplen);
		clen += apdu->resplen;
	}

	while(apdu->sw1 == 0x95) {
	
		tmc_format_apdu(apdu, SC_APDU_CASE_2_SHORT, apdu_getRespData);

		apdu->le = apdu->sw2;
		apdu->resp = buf;
		apdu->resplen = apdu->le;
		
		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			memcpy(apduBuf+clen, apdu->resp, apdu->resplen);
			clen += apdu->resplen;
		}
	}

	if(cipherkey != NULL) {
		if((unsigned int)clen > (unsigned int)(*cipherkey_len)) {
			rv = CKR_BUFFER_TOO_SMALL;
			goto out;
		}
		memcpy(cipherkey, apduBuf, clen);
	}
	*cipherkey_len = clen;
	
	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_export_pubkey(struct tmc_card *card, u16 fid, u8 *key, CK_ULONG *key_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	CK_ULONG clen=0;

	if((card == NULL)||(key_len == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_exportKey);

	//set fid
	buf[0] = (u8)(fid >> 8);
	buf[1] = (u8)(fid & 0x00FF);

	apdu->lc = 0x02;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	apdu->le = 0x00;
	apdu->resp = buf;
	apdu->resplen = apdu->le;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	if(apdu->resplen != 0x00) {
		memcpy(apduBuf+clen, apdu->resp, apdu->resplen);
		clen += apdu->resplen;
	}

	while(apdu->sw1 == 0x95) {
	
		tmc_format_apdu(apdu, SC_APDU_CASE_2_SHORT, apdu_getRespData);

		apdu->le = apdu->sw2;
		apdu->resp = buf;
		apdu->resplen = apdu->le;
		
		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			memcpy(apduBuf+clen, apdu->resp, apdu->resplen);
			clen += apdu->resplen;
		}
	}

	if(key != NULL) {
		if((unsigned int)clen > (unsigned int)(*key_len)) {
			clen= *key_len;
		}
		memcpy(key, apduBuf, clen);
	}
	*key_len = clen;

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_wrap_key(struct tmc_card *card, tmcse_key_t *key, u8 *wrapkey, CK_ULONG wrapkey_len, u8 * wrappedkey, CK_ULONG * wrappedkey_len)
{
	return CKR_OK;
}

CK_RV tmcse_unwrap_key(struct tmc_card *card, u8 *wrappedkey, CK_ULONG wrappedkey_len, tmcse_key_t *prikey, u16 fid)
{
	return CKR_OK;
}

CK_RV tmcse_unwrap_key_ex(struct tmc_card *card, u8 * wrappedkey, CK_ULONG * wrappedkey_len, tmcse_key_t *prikey, u8 *key, CK_ULONG *key_len)
{
	return CKR_OK;
}

CK_RV tmcse_ecc_exchangekey(struct tmc_card *card, CK_ULONG algtype, u16 pri_fid, u8 *pubkey, CK_ULONG pub_len, u16 fid)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 alg,len;
	CK_ULONG off=0,dataLen=0;

	if((card == NULL) || (pubkey == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	switch(algtype) {
		case CKK_DES:
			alg = 0x00;
			break;
		case CKK_DES2:
			alg = 0x01;
			break;
		case CKK_DES3:
			alg = 0x02;
			break;
		case CKK_AES:
			alg = 0x03;
			break;
		case CKK_SM1:
			alg = 0x04;
			break;
		case CKK_SM4:
			alg = 0x05;
			break;
		default:
			return CKR_ARGUMENTS_BAD;
	}

	if((pub_len > SC_MAX_LENGTH_SIZE) || (pub_len == 0x00)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_exchangeKey);

	apduBuf[dataLen++] = 0x00;//Token
	apduBuf[dataLen++] = 0x06;//ECC
	apduBuf[dataLen++] = alg;//session key type

	//set prikey_A
	apduBuf[dataLen++] = (u8)(pri_fid >> 8);
	apduBuf[dataLen++] = (u8)(pri_fid & 0x00FF);
	
	//set pubkey_B
	apduBuf[dataLen++] = (u8)(pub_len >> 8);
	apduBuf[dataLen++] = (u8)(pub_len & 0x00FF);
	memcpy(apduBuf+dataLen, pubkey, pub_len);
	dataLen += pub_len;
	
	//set session key id
	apduBuf[dataLen++] = (u8)(fid >> 8);
	apduBuf[dataLen++] = (u8)(fid & 0x00FF);

	if (dataLen <= SC_MAX_SEND_BUFF_CFG_SIZE) {
		apdu->p1 = 0x00;//unique block
		memcpy(buf, apduBuf, dataLen);

		apdu->lc = dataLen;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}
	else {
	
		while (off < dataLen) {

			if ((dataLen - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
				len = SC_MAX_SEND_BUFF_CFG_SIZE;
				if (off == 0x00) {
					apdu->p1 = 0x01;//first block
				} else {
					apdu->p1 = 0x02;//mid block
				}
			} else {
				len = (dataLen - off);
				apdu->p1 = 0x03;//last block
			}

			memcpy(buf, apduBuf+off, len);
			off += len;

			apdu->lc = len;
			apdu->data = buf;
			apdu->datalen = apdu->lc;

			rv = tmc_transmit_apdu(card, apdu);
			if (rv != CKR_OK) {
				goto out;
			}

			rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
			if (rv != CKR_OK) {
				goto out;
			}
		}
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_ecc_exchangekey_ex(struct tmc_card *card, CK_ULONG algtype, u16 pri_fid, u8 *pubkey, CK_ULONG pub_len, u8 *key, CK_ULONG *key_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 alg,len;
	CK_ULONG off=0,dataLen=0;

	if((card == NULL) || (pubkey == NULL) || (key_len == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	switch(algtype) {
		case CKK_DES:
			alg = 0x00;
			break;
		case CKK_DES2:
			alg = 0x01;
			break;
		case CKK_DES3:
			alg = 0x02;
			break;
		case CKK_AES:
			alg = 0x03;
			break;
		case CKK_SM1:
			alg = 0x04;
			break;
		case CKK_SM4:
			alg = 0x05;
			break;
		default:
			return CKR_ARGUMENTS_BAD;
	}

	if((pub_len > SC_MAX_LENGTH_SIZE) || (pub_len == 0x00)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_exchangeKey);

	apduBuf[dataLen++] = 0x00;//Token
	apduBuf[dataLen++] = 0x06;//ECC
	apduBuf[dataLen++] = alg;//session key type

	//set prikey_A
	apduBuf[dataLen++] = (u8)(pri_fid >> 8);
	apduBuf[dataLen++] = (u8)(pri_fid & 0x00FF);
	
	//set pubkey_B
	apduBuf[dataLen++] = (u8)(pub_len >> 8);
	apduBuf[dataLen++] = (u8)(pub_len & 0x00FF);
	memcpy(apduBuf+dataLen, pubkey, pub_len);
	dataLen += pub_len;

	if (dataLen <= SC_MAX_SEND_BUFF_CFG_SIZE) {
		apdu->p1 = 0x00;//unique block
		memcpy(buf, apduBuf, dataLen);

		apdu->lc = dataLen;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		apdu->le = 0x00;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}
	else {
	
		while (off < dataLen) {

			if ((dataLen - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
				len = SC_MAX_SEND_BUFF_CFG_SIZE;
				if (off == 0x00) {
					apdu->p1 = 0x01;//first block
				} else {
					apdu->p1 = 0x02;//mid block
				}
			} else {
				len = (dataLen - off);
				apdu->p1 = 0x03;//last block
			}

			memcpy(buf, apduBuf+off, len);
			off += len;

			apdu->lc = len;
			apdu->data = buf;
			apdu->datalen = apdu->lc;

			apdu->le = 0x00;
			apdu->resp = buf;
			apdu->resplen = apdu->le;

			rv = tmc_transmit_apdu(card, apdu);
			if (rv != CKR_OK) {
				goto out;
			}

			rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
			if (rv != CKR_OK) {
				goto out;
			}
		}
	}

	if(apdu->resplen != 0x00) {
		if(key != NULL) {
			if(apdu->resplen > (unsigned int)(*key_len)) {
				rv = CKR_BUFFER_TOO_SMALL;
				goto out;
			}
			memcpy(key, apdu->resp, apdu->resplen);
		}
	}
	*key_len = apdu->resplen;

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_sm2_exchangekey(struct tmc_card *card, CK_ULONG algtype, u16 pub_fid, u16 pri_fid, u8 *idA, CK_ULONG lenA, u8 *pubkey, CK_ULONG pub_len, u8 *idB, CK_ULONG lenB, u16 fid)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 alg,len;
	CK_ULONG off=0,dataLen=0;

	if((card == NULL) || (pubkey == NULL) || (idA == NULL) || (idB == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	switch(algtype) {
		case CKK_DES:
			alg = 0x00;
			break;
		case CKK_DES2:
			alg = 0x01;
			break;
		case CKK_DES3:
			alg = 0x02;
			break;
		case CKK_AES:
			alg = 0x03;
			break;
		case CKK_SM1:
			alg = 0x04;
			break;
		case CKK_SM4:
			alg = 0x05;
			break;
		default:
			return CKR_ARGUMENTS_BAD;
	}

	if((pub_len > SC_MAX_LENGTH_SIZE) || (pub_len == 0x00)) {
		return CKR_DATA_LEN_RANGE;
	}

	if((lenA > SC_MAX_ID_SIZE) || (lenA == 0x00) || (lenB > SC_MAX_ID_SIZE) || (lenB == 0x00)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_exchangeKey);

	apduBuf[dataLen++] = 0x00;//Token
	apduBuf[dataLen++] = 0x07;//SM2
	apduBuf[dataLen++] = alg;//session key type

	//set pubkey_A
	apduBuf[dataLen++] = (u8)(pub_fid >> 8);
	apduBuf[dataLen++] = (u8)(pub_fid & 0x00FF);
	//set prikey_A
	apduBuf[dataLen++] = (u8)(pri_fid >> 8);
	apduBuf[dataLen++] = (u8)(pri_fid & 0x00FF);
	//set ID_A
	apduBuf[dataLen++] = (u8)(lenA >> 8);
	apduBuf[dataLen++] = (u8)(lenA & 0x00FF);
	memcpy(apduBuf+dataLen, idA, lenA);
	dataLen += lenA;

	//set pubkey_B
	apduBuf[dataLen++] = (u8)(pub_len >> 8);
	apduBuf[dataLen++] = (u8)(pub_len & 0x00FF);
	memcpy(apduBuf+dataLen, pubkey, pub_len);
	dataLen += pub_len;
	//set ID_B
	apduBuf[dataLen++] = (u8)(lenB >> 8);
	apduBuf[dataLen++] = (u8)(lenB & 0x00FF);
	memcpy(apduBuf+dataLen, idB, lenB);
	dataLen += lenB;
	
	//set session key id
	apduBuf[dataLen++] = (u8)(fid >> 8);
	apduBuf[dataLen++] = (u8)(fid & 0x00FF);

	if (dataLen <= SC_MAX_SEND_BUFF_CFG_SIZE) {
		apdu->p1 = 0x00;//unique block
		memcpy(buf, apduBuf, dataLen);

		apdu->lc = dataLen;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}
	else {
	
		while (off < dataLen) {

			if ((dataLen - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
				len = SC_MAX_SEND_BUFF_CFG_SIZE;
				if (off == 0x00) {
					apdu->p1 = 0x01;//first block
				} else {
					apdu->p1 = 0x02;//mid block
				}
			} else {
				len = (dataLen - off);
				apdu->p1 = 0x03;//last block
			}

			memcpy(buf, apduBuf+off, len);
			off += len;

			apdu->lc = len;
			apdu->data = buf;
			apdu->datalen = apdu->lc;

			rv = tmc_transmit_apdu(card, apdu);
			if (rv != CKR_OK) {
				goto out;
			}

			rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
			if (rv != CKR_OK) {
				goto out;
			}
		}
	}

	out:
	free(apdu);
	return rv;
}


CK_RV tmcse_sm2_exchangekey_ex(struct tmc_card *card, CK_ULONG algtype, u16 pub_fid, u16 pri_fid, u8 *idA, CK_ULONG lenA, u8 *pubkey, CK_ULONG pub_len, u8 *idB, CK_ULONG lenB, u8 *key, CK_ULONG *key_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 alg,len;
	CK_ULONG off=0,dataLen=0;

	if((card == NULL) || (pubkey == NULL) || (idA == NULL) || (idB == NULL) || (key_len == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	switch(algtype) {
		case CKK_DES:
			alg = 0x00;
			break;
		case CKK_DES2:
			alg = 0x01;
			break;
		case CKK_DES3:
			alg = 0x02;
			break;
		case CKK_AES:
			alg = 0x03;
			break;
		case CKK_SM1:
			alg = 0x04;
			break;
		case CKK_SM4:
			alg = 0x05;
			break;
		default:
			return CKR_ARGUMENTS_BAD;
	}

	if((pub_len > SC_MAX_LENGTH_SIZE) || (pub_len == 0x00)) {
		return CKR_DATA_LEN_RANGE;
	}

	if((lenA > SC_MAX_ID_SIZE) || (lenA == 0x00) || (lenB > SC_MAX_ID_SIZE) || (lenB == 0x00)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_exchangeKey);

	apduBuf[dataLen++] = 0x10;//Token
	apduBuf[dataLen++] = 0x07;//SM2
	apduBuf[dataLen++] = alg;//session key type

	//set pubkey_A
	apduBuf[dataLen++] = (u8)(pub_fid >> 8);
	apduBuf[dataLen++] = (u8)(pub_fid & 0x00FF);
	//set prikey_A
	apduBuf[dataLen++] = (u8)(pri_fid >> 8);
	apduBuf[dataLen++] = (u8)(pri_fid & 0x00FF);
	//set ID_A
	apduBuf[dataLen++] = (u8)(lenA >> 8);
	apduBuf[dataLen++] = (u8)(lenA & 0x00FF);
	memcpy(apduBuf+dataLen, idA, lenA);
	dataLen += lenA;

	//set pubkey_B
	apduBuf[dataLen++] = (u8)(pub_len >> 8);
	apduBuf[dataLen++] = (u8)(pub_len & 0x00FF);
	memcpy(apduBuf+dataLen, pubkey, pub_len);
	dataLen += pub_len;
	//set ID_B
	apduBuf[dataLen++] = (u8)(lenB >> 8);
	apduBuf[dataLen++] = (u8)(lenB & 0x00FF);
	memcpy(apduBuf+dataLen, idB, lenB);
	dataLen += lenB;
	
	if (dataLen <= SC_MAX_SEND_BUFF_CFG_SIZE) {
		apdu->p1 = 0x00;//unique block
		memcpy(buf, apduBuf, dataLen);

		apdu->lc = dataLen;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		apdu->le = 0x00;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}
	else {
	
		while (off < dataLen) {

			if ((dataLen - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
				len = SC_MAX_SEND_BUFF_CFG_SIZE;
				if (off == 0x00) {
					apdu->p1 = 0x01;//first block
				} else {
					apdu->p1 = 0x02;//mid block
				}
			} else {
				len = (dataLen - off);
				apdu->p1 = 0x03;//last block
			}

			memcpy(buf, apduBuf+off, len);
			off += len;

			apdu->lc = len;
			apdu->data = buf;
			apdu->datalen = apdu->lc;

			apdu->le = 0x00;
			apdu->resp = buf;
			apdu->resplen = apdu->le;

			rv = tmc_transmit_apdu(card, apdu);
			if (rv != CKR_OK) {
				goto out;
			}

			rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
			if (rv != CKR_OK) {
				goto out;
			}
		}
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_dh_exchangekey(struct tmc_card *card, CK_ULONG algtype, u16 pri_fid, u8 *pubkey, CK_ULONG pub_len, u16 fid)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 alg,len;
	CK_ULONG off=0,dataLen=0;

	if((card == NULL) || (pubkey == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	switch(algtype) {
		case CKK_DES:
			alg = 0x00;
			break;
		case CKK_DES2:
			alg = 0x01;
			break;
		case CKK_DES3:
			alg = 0x02;
			break;
		case CKK_AES:
			alg = 0x03;
			break;
		case CKK_SM1:
			alg = 0x04;
			break;
		case CKK_SM4:
			alg = 0x05;
			break;
		default:
			return CKR_ARGUMENTS_BAD;
	}

	if((pub_len > SC_MAX_LENGTH_SIZE) || (pub_len == 0x00)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_exchangeKey);

	apduBuf[dataLen++] = 0x00;//Token
	apduBuf[dataLen++] = 0x08;//DH
	apduBuf[dataLen++] = alg;//session key type

	//set prikey_A
	apduBuf[dataLen++] = (u8)(pri_fid >> 8);
	apduBuf[dataLen++] = (u8)(pri_fid & 0x00FF);
	
	//set pubkey_B
	apduBuf[dataLen++] = (u8)(pub_len >> 8);
	apduBuf[dataLen++] = (u8)(pub_len & 0x00FF);
	memcpy(apduBuf+dataLen, pubkey, pub_len);
	dataLen += pub_len;
	
	//set session key id
	apduBuf[dataLen++] = (u8)(fid >> 8);
	apduBuf[dataLen++] = (u8)(fid & 0x00FF);

	if (dataLen <= SC_MAX_SEND_BUFF_CFG_SIZE) {
		apdu->p1 = 0x00;//unique block
		memcpy(buf, apduBuf, dataLen);

		apdu->lc = dataLen;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}
	else {
	
		while (off < dataLen) {

			if ((dataLen - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
				len = SC_MAX_SEND_BUFF_CFG_SIZE;
				if (off == 0x00) {
					apdu->p1 = 0x01;//first block
				} else {
					apdu->p1 = 0x02;//mid block
				}
			} else {
				len = (dataLen - off);
				apdu->p1 = 0x03;//last block
			}

			memcpy(buf, apduBuf+off, len);
			off += len;

			apdu->lc = len;
			apdu->data = buf;
			apdu->datalen = apdu->lc;

			rv = tmc_transmit_apdu(card, apdu);
			if (rv != CKR_OK) {
				goto out;
			}

			rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
			if (rv != CKR_OK) {
				goto out;
			}
		}
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_dh_exchangekey_ex(struct tmc_card *card, CK_ULONG algtype, u16 pri_fid, u8 *pubkey, CK_ULONG pub_len, u8 *key, CK_ULONG *key_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 alg,len;
	CK_ULONG off=0,dataLen=0;

	if((card == NULL) || (pubkey == NULL) || (key_len == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	switch(algtype) {
		case CKK_DES:
			alg = 0x00;
			break;
		case CKK_DES2:
			alg = 0x01;
			break;
		case CKK_DES3:
			alg = 0x02;
			break;
		case CKK_AES:
			alg = 0x03;
			break;
		case CKK_SM1:
			alg = 0x04;
			break;
		case CKK_SM4:
			alg = 0x05;
			break;
		default:
			return CKR_ARGUMENTS_BAD;
	}

	if((pub_len > SC_MAX_LENGTH_SIZE) || (pub_len == 0x00)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_exchangeKey);

	apduBuf[dataLen++] = 0x00;//Token
	apduBuf[dataLen++] = 0x08;//DH
	apduBuf[dataLen++] = alg;//session key type

	//set prikey_A
	apduBuf[dataLen++] = (u8)(pri_fid >> 8);
	apduBuf[dataLen++] = (u8)(pri_fid & 0x00FF);
	
	//set pubkey_B
	apduBuf[dataLen++] = (u8)(pub_len >> 8);
	apduBuf[dataLen++] = (u8)(pub_len & 0x00FF);
	memcpy(apduBuf+dataLen, pubkey, pub_len);
	dataLen += pub_len;

	if (dataLen <= SC_MAX_SEND_BUFF_CFG_SIZE) {
		apdu->p1 = 0x00;//unique block
		memcpy(buf, apduBuf, dataLen);

		apdu->lc = dataLen;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		apdu->le = 0x00;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}
	else {
	
		while (off < dataLen) {

			if ((dataLen - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
				len = SC_MAX_SEND_BUFF_CFG_SIZE;
				if (off == 0x00) {
					apdu->p1 = 0x01;//first block
				} else {
					apdu->p1 = 0x02;//mid block
				}
			} else {
				len = (dataLen - off);
				apdu->p1 = 0x03;//last block
			}

			memcpy(buf, apduBuf+off, len);
			off += len;

			apdu->lc = len;
			apdu->data = buf;
			apdu->datalen = apdu->lc;

			apdu->le = 0x00;
			apdu->resp = buf;
			apdu->resplen = apdu->le;

			rv = tmc_transmit_apdu(card, apdu);
			if (rv != CKR_OK) {
				goto out;
			}

			rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
			if (rv != CKR_OK) {
				goto out;
			}
		}
	}

	if(apdu->resplen != 0x00) {
		if(key != NULL) {
			if(apdu->resplen > (unsigned int)(*key_len)) {
				rv = CKR_BUFFER_TOO_SMALL;
				goto out;
			}
			memcpy(key, apdu->resp, apdu->resplen);
		}
	}
	*key_len = apdu->resplen;

	out:
	free(apdu);
	return rv;
}


//alg operation
CK_RV tmcse_enc_data(struct tmc_card *card, CK_ULONG mechanism, tmcse_key_t *key, u8 *plain, CK_ULONG length, u8 *iv, CK_ULONG ivlen, u8 *cipher, CK_ULONG *cipher_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len,alg,cbc=0;
	CK_ULONG off=0,clen=0,sendLen=0;

	if((card == NULL) || (key == NULL) || (plain == NULL) ||(cipher == NULL)|| (cipher_len == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((length == 0)||(length > SC_MAX_LENGTH_SIZE)||(ivlen > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	switch(mechanism) {
        case CKM_AES_GCM:
		case CKM_AES_ECB:
			alg = 0x00;
			break;
		case CKM_AES_CBC:
		case CKM_AES_CBC_PAD:
			if(iv == NULL) {
				return CKR_ARGUMENTS_BAD;
			}
			cbc = 0x01;
			alg = 0x01;
			break;
		case CKM_DES_ECB:
		case CKM_DES3_ECB:
			alg = 0x04;
			break;
		case CKM_DES_CBC:
		case CKM_DES_CBC_PAD:
		case CKM_DES3_CBC:
		case CKM_DES3_CBC_PAD:
			if(iv == NULL) {
				return CKR_ARGUMENTS_BAD;
			}
			cbc = 0x01;
			alg = 0x05;
			break;
		case CKM_SM1_ECB:
			alg = 0x06;
			break;
		case CKM_SM1_CBC:
			if(iv == NULL) {
				return CKR_ARGUMENTS_BAD;
			}
			cbc = 0x01;
			alg = 0x07;
			break;
		case CKM_SM4_ECB:
			alg = 0x08;
			break;
		case CKM_SM4_CBC:
			if(iv == NULL) {
				return CKR_ARGUMENTS_BAD;
			}
			cbc = 0x01;
			alg = 0x09;
			break;			
		case CKM_SM1_CBC_PAD:
		case CKM_SM4_CBC_PAD:
		case CKM_AES_CCM:
		default:
			return CKR_FUNCTION_NOT_SUPPORTED;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_symAlgOpera);

#if 0
	while(sendLen < length) {
		off = 0;
		//session
		if(key->isToken == CK_FALSE) {
			buf[off++] = 0x10;
			buf[off++] = alg;
			buf[off++] = (u8)(key->key.value.length >> 8);
			buf[off++] = (u8)(key->key.value.length & 0x00ff);
			memcpy(buf+off, key->key.value.data, key->key.value.length);//key cipher
			off += key->key.value.length;
			if(cbc == 0x01) {
				buf[off++] = (u8)(ivlen >> 8);
				buf[off++] = (u8)(ivlen & 0x00ff);
				memcpy(buf+off, iv, ivlen);//iv
				off += ivlen;
			}
		}
			//token
		else {
			buf[off++] = 0x00;
			buf[off++] = alg;
			buf[off++] = (u8)((key->key.fid) >> 8);
			buf[off++] = (u8)((key->key.fid) & 0x00FF);
			if(cbc == 0x01) {
				buf[off++] = (u8)(ivlen >> 8);
				buf[off++] = (u8)(ivlen & 0x00ff);
				memcpy(buf+off, iv, ivlen);//iv
				off += ivlen;
			}
		}

		len = (u8)((SC_MAX_SEND_BUFF_CFG_SIZE - off) & 0xF0);//send fixed length everytime

		if((length - sendLen) < len) {
			len = length - sendLen;
		}

		buf[off++] = (u8)(len >> 8);
		buf[off++] = (u8)(len & 0x00ff);

		memcpy(buf+off, plain+sendLen, len);//plain text
		sendLen += len;

		apdu->lc = off+len;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		apdu->le = 0;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			memcpy(cipher+clen, apdu->resp, apdu->resplen);
			clen += apdu->resplen;
		}
	}
#else

	//session
	if(key->isToken == CK_FALSE) {
		buf[off++] = 0x10;
		buf[off++] = alg;
		buf[off++] = (u8)(key->key.value.length >> 8);
		buf[off++] = (u8)(key->key.value.length & 0x00ff);
		memcpy(buf+off, key->key.value.data, key->key.value.length);//key cipher
		off += key->key.value.length;
		if(cbc == 0x01) {
			buf[off++] = (u8)(ivlen >> 8);
			buf[off++] = (u8)(ivlen & 0x00ff);
			memcpy(buf+off, iv, ivlen);//iv
			off += ivlen;
		}
	}
	//token
	else {
		buf[off++] = 0x00;
		buf[off++] = alg;
		buf[off++] = (u8)((key->key.fid) >> 8);
		buf[off++] = (u8)((key->key.fid) & 0x00FF);
		if(cbc == 0x01) {
			buf[off++] = (u8)(ivlen >> 8);
			buf[off++] = (u8)(ivlen & 0x00ff);
			memcpy(buf+off, iv, ivlen);//iv
			off += ivlen;
		}
	}

	if(length > (SC_MAX_SEND_BUFF_CFG_SIZE - off)) {
		len = (SC_MAX_SEND_BUFF_CFG_SIZE - off);
		apdu->p1 = 0x01;//first block
	}
	else {
		len = length;
		apdu->p1 = 0x00;//unique block
	}

	memcpy(buf+off, plain, len);//plain text
	sendLen = len;

	apdu->lc = off+len;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	apdu->le = 0;
	apdu->resp = buf;
	apdu->resplen = apdu->le;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}
	
	if(apdu->resplen != 0x00) {
		memcpy(cipher+clen, apdu->resp, apdu->resplen);
		clen += apdu->resplen;
	}

	while(sendLen < length) {
		tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_symAlgOpera);

		if((length - sendLen) > SC_MAX_SEND_BUFF_CFG_SIZE) {
			len = SC_MAX_SEND_BUFF_CFG_SIZE;
			apdu->p1 = 0x02;//mid block
		}
		else {
			len = (length - sendLen);
			apdu->p1 = 0x03;//last block
		}

		memcpy(buf, plain+sendLen, len);//plain text
		sendLen += len;

		apdu->lc = len;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		apdu->le = 0;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			memcpy(cipher+clen, apdu->resp, apdu->resplen);
			clen += apdu->resplen;
		}
	}
#endif

	*cipher_len = clen;

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_dec_data(struct tmc_card *card, CK_ULONG mechanism, tmcse_key_t *key, u8 *cipher, CK_ULONG length, u8 *iv, CK_ULONG ivlen, u8 *plain, CK_ULONG *plain_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len,alg,cbc=0;
	CK_ULONG off=0,clen=0,sendLen=0;

	if((card == NULL) || (key == NULL) || (cipher == NULL) ||(plain == NULL)|| (plain_len == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((length == 0)||(length > SC_MAX_LENGTH_SIZE)||(ivlen > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	switch(mechanism) {
		case CKM_AES_GCM:
		case CKM_AES_ECB:
			alg = 0x00;
			break;
		case CKM_AES_CBC:
		case CKM_AES_CBC_PAD:
			if(iv == NULL) {
				return CKR_ARGUMENTS_BAD;
			}
			cbc = 0x01;
			alg = 0x01;
			break;
		case CKM_DES_ECB:
		case CKM_DES3_ECB:
			alg = 0x04;
			break;
		case CKM_DES_CBC:
		case CKM_DES_CBC_PAD:
		case CKM_DES3_CBC:
		case CKM_DES3_CBC_PAD:
			if(iv == NULL) {
				return CKR_ARGUMENTS_BAD;
			}
			cbc = 0x01;
			alg = 0x05;
			break;
		case CKM_SM1_ECB:
			alg = 0x06;
			break;
		case CKM_SM1_CBC:
			if(iv == NULL) {
				return CKR_ARGUMENTS_BAD;
			}
			cbc = 0x01;
			alg = 0x07;
			break;
		case CKM_SM4_ECB:
			alg = 0x08;
			break;
		case CKM_SM4_CBC:
			if(iv == NULL) {
				return CKR_ARGUMENTS_BAD;
			}
			cbc = 0x01;
			alg = 0x09;
			break;			
		case CKM_SM1_CBC_PAD:
		case CKM_SM4_CBC_PAD:
		case CKM_AES_CCM:
		default:
			return CKR_FUNCTION_NOT_SUPPORTED;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_symAlgOpera);

#if 0
	while(sendLen < length) {
		off = 0;
		//session
		if(key->isToken == CK_FALSE) {
			buf[off++] = 0x11;
			buf[off++] = alg;
			buf[off++] = (u8)(key->key.value.length >> 8);
			buf[off++] = (u8)(key->key.value.length & 0x00ff);
			memcpy(buf+off, key->key.value.data, key->key.value.length);//key cipher
			off += key->key.value.length;
			if(cbc == 0x01) {
				buf[off++] = (u8)(ivlen >> 8);
				buf[off++] = (u8)(ivlen & 0x00ff);
				memcpy(buf+off, iv, ivlen);//iv
				off += ivlen;
			}
		}
			//token
		else {
			buf[off++] = 0x01;
			buf[off++] = alg;
			buf[off++] = (u8)((key->key.fid) >> 8);
			buf[off++] = (u8)((key->key.fid) & 0x00FF);
			if(cbc == 0x01) {
				buf[off++] = (u8)(ivlen >> 8);
				buf[off++] = (u8)(ivlen & 0x00ff);
				memcpy(buf+off, iv, ivlen);//iv
				off += ivlen;
			}
		}

		len = (u8)((SC_MAX_SEND_BUFF_CFG_SIZE - off) & 0xF0);//send fixed length everytime

		if((length - sendLen) < len) {
			len = length - sendLen;
		}

		buf[off++] = (u8)(len >> 8);
		buf[off++] = (u8)(len & 0x00ff);

		memcpy(buf+off, cipher+sendLen, len);//cipher text
		sendLen += len;

		apdu->lc = off+len;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		apdu->le = 0;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			memcpy(cipher+clen, apdu->resp, apdu->resplen);
			clen += apdu->resplen;
		}
	}
#else

	//session
	if(key->isToken == CK_FALSE) {
		buf[off++] = 0x11;
		buf[off++] = alg;
		buf[off++] = (u8)(key->key.value.length >> 8);
		buf[off++] = (u8)(key->key.value.length & 0x00ff);
		memcpy(buf+off, key->key.value.data, key->key.value.length);//key cipher
		off += key->key.value.length;
		if(cbc == 0x01) {
			buf[off++] = (u8)(ivlen >> 8);
			buf[off++] = (u8)(ivlen & 0x00ff);
			memcpy(buf+off, iv, ivlen);//iv
			off += ivlen;
		}
	}
		//token
	else {
		buf[off++] = 0x01;
		buf[off++] = alg;
		buf[off++] = (u8)((key->key.fid) >> 8);
		buf[off++] = (u8)((key->key.fid) & 0x00FF);
		if(cbc == 0x01) {
			buf[off++] = (u8)(ivlen >> 8);
			buf[off++] = (u8)(ivlen & 0x00ff);
			memcpy(buf+off, iv, ivlen);//iv
			off += ivlen;
		}
	}

	if(length > (SC_MAX_SEND_BUFF_CFG_SIZE - off)) {
		len = (SC_MAX_SEND_BUFF_CFG_SIZE - off);
		apdu->p1 = 0x01;//first block
	}
	else {
		len = length;
		apdu->p1 = 0x00;//unique block
	}

	memcpy(buf+off, cipher, len);//cipher text
	sendLen = len;

	apdu->lc = off+len;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	apdu->le = 0;
	apdu->resp = buf;
	apdu->resplen = apdu->le;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	if(apdu->resplen != 0x00) {
		memcpy(plain+clen, apdu->resp, apdu->resplen);
		clen += apdu->resplen;
	}

	while(sendLen < length) {
		tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_symAlgOpera);

		if((length - sendLen) > SC_MAX_SEND_BUFF_CFG_SIZE) {
			len = SC_MAX_SEND_BUFF_CFG_SIZE;
			apdu->p1 = 0x02;//mid block
		}
		else {
			len = (length - sendLen);
			apdu->p1 = 0x03;//last block
		}

		memcpy(buf, cipher+sendLen, len);//cipher text
		sendLen += len;

		apdu->lc = len;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		apdu->le = 0;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			memcpy(plain+clen, apdu->resp, apdu->resplen);
			clen += apdu->resplen;
		}
	}

#endif
	*plain_len = clen;

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_encrypt(struct tmc_card *card, CK_ULONG mechanism, CK_ULONG keytype, tmcse_key_t *key, u8 *plain, CK_ULONG length, u8 *cipher, CK_ULONG *cipher_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len,alg;
	CK_ULONG off=0,clen=0,dataLen=0;

	if((card == NULL) || (key == NULL) || (plain == NULL) ||(cipher_len == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((length == 0)||(length > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	switch(mechanism) {
		case CKM_RSA_PKCS:
		case CKM_RSA_9796 :
		case CKM_RSA_X_509:
		case CKM_MD5_RSA_PKCS:
		case CKM_SHA1_RSA_PKCS :
		case CKM_SHA224_RSA_PKCS:
		case CKM_SHA256_RSA_PKCS:
		case CKM_SHA384_RSA_PKCS:
		case CKM_SHA512_RSA_PKCS:
		case CKM_RIPEMD160_RSA_PKCS:
            alg = 0x00;//公钥不区分CRT或ND
			break;
		case CKM_SM2_SM3_256:
			alg = 0x07;
			break;
		case CKM_ECDSA:
		default:
			return CKR_FUNCTION_NOT_SUPPORTED;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_asymAlgOpera);

#if 0
	while(sendLen < length) {
		off = 0;
		//session
		if(key->isToken == CK_FALSE) {
			buf[off++] = 0x10;
			buf[off++] = alg;
			buf[off++] = (u8)(key->key.value.length >> 8);
			buf[off++] = (u8)(key->key.value.length & 0x00ff);
			memcpy(buf+off, key->key.value.data, key->key.value.length);//key cipher
			off += key->key.value.length;
		}
			//token
		else {
			buf[off++] = 0x00;
			buf[off++] = alg;
			buf[off++] = (u8)((key->key.fid) >> 8);
			buf[off++] = (u8)((key->key.fid) & 0x00FF);
		}

		len = (u8)((SC_MAX_SEND_BUFF_CFG_SIZE - off) & 0xF0);//send fixed length everytime

		if((length - sendLen) < len) {
			len = length - sendLen;
		}

		buf[off++] = (u8)(len >> 8);
		buf[off++] = (u8)(len & 0x00ff);

		memcpy(buf+off, plain+sendLen, len);//plain text
		sendLen += len;

		apdu->lc = off+len;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		apdu->le = 0;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			memcpy(cipher+clen, apdu->resp, apdu->resplen);
			clen += apdu->resplen;
		}
	}
#else

	//session
	if(key->isToken == CK_FALSE) {
		apduBuf[dataLen++] = 0x10;
		apduBuf[dataLen++] = alg;
		apduBuf[dataLen++] = (u8)(key->key.value.length >> 8);
		apduBuf[dataLen++] = (u8)(key->key.value.length & 0x00ff);
		memcpy(apduBuf+dataLen, key->key.value.data, key->key.value.length);//key cipher
		dataLen += key->key.value.length;
	}
	//token
	else {
		apduBuf[dataLen++] = 0x00;
		apduBuf[dataLen++] = alg;
		apduBuf[dataLen++] = (u8)((key->key.fid) >> 8);
		apduBuf[dataLen++] = (u8)((key->key.fid) & 0x00FF);
	}

	apduBuf[dataLen++] = (u8)(length >> 8);
	apduBuf[dataLen++] = (u8)(length & 0x00ff);
	memcpy(apduBuf+dataLen, plain, length);//plain text
	dataLen += length;

	if (dataLen <= SC_MAX_SEND_BUFF_CFG_SIZE) {
		apdu->p1 = 0x00;//unique block
		memcpy(buf, apduBuf, dataLen);

		apdu->lc = dataLen;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		apdu->le = 0x00;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}
	else {

		while (off < dataLen) {

			if ((dataLen - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
				len = SC_MAX_SEND_BUFF_CFG_SIZE;
				if (off == 0x00) {
					apdu->p1 = 0x01;//first block
				} else {
					apdu->p1 = 0x02;//mid block
				}
			} else {
				len = (dataLen - off);
				apdu->p1 = 0x03;//last block
			}

			memcpy(buf, apduBuf+off, len);
			off += len;

			apdu->lc = len;
			apdu->data = buf;
			apdu->datalen = apdu->lc;

			apdu->le = 0x00;
			apdu->resp = buf;
			apdu->resplen = apdu->le;

			rv = tmc_transmit_apdu(card, apdu);
			if (rv != CKR_OK) {
				goto out;
			}

			rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
			if (rv != CKR_OK) {
				goto out;
			}
		}
	}

	if (apdu->resplen != 0x00) {
		if ((clen + apdu->resplen) > SC_MAX_CACHE_SIZE) {
			rv = CKR_BUFFER_TOO_SMALL;
			goto out;
		}
		memcpy(apduBuf + clen, apdu->resp, apdu->resplen);
		clen += apdu->resplen;
	}

	while(apdu->sw1 == 0x95) {

		tmc_format_apdu(apdu, SC_APDU_CASE_2_SHORT, apdu_getRespData);

		apdu->lc = apdu->sw2;
		apdu->resp = buf;
		apdu->resplen = apdu->lc;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			if((clen + apdu->resplen) > SC_MAX_CACHE_SIZE) {
				rv = CKR_BUFFER_TOO_SMALL;
				goto out;
			}
			memcpy(apduBuf+clen, apdu->resp, apdu->resplen);
			clen += apdu->resplen;
		}
	}
#endif
	if(cipher != NULL) {
		if((unsigned int)clen > (unsigned int)(*cipher_len)) {
			rv = CKR_BUFFER_TOO_SMALL;
			goto out;
		}
		memcpy(cipher, apduBuf, clen);
	}
	*cipher_len = clen;

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_decrypt(struct tmc_card *card, CK_ULONG mechanism, CK_ULONG keytype, tmcse_key_t *key, u8 *cipher, CK_ULONG length, u8 *plain, CK_ULONG *plain_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len,alg;
	CK_ULONG off=0,clen=0,dataLen=0;

	if((card == NULL) || (key == NULL) || (cipher == NULL) || (plain_len == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((length == 0)||(length > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	switch(mechanism) {
		case CKM_RSA_PKCS:
		case CKM_RSA_9796 :
		case CKM_RSA_X_509:
		case CKM_MD5_RSA_PKCS:
		case CKM_SHA1_RSA_PKCS :
		case CKM_SHA224_RSA_PKCS:
		case CKM_SHA256_RSA_PKCS:
		case CKM_SHA384_RSA_PKCS:
		case CKM_SHA512_RSA_PKCS:
		case CKM_RIPEMD160_RSA_PKCS:
		    if(key->isToken == CK_FALSE) {
                if(keytype == RSA_KEY_TYPE_ND) {
                    alg = 0x00;
                }
                else if(keytype == RSA_KEY_TYPE_CRT) {
                    alg = 0x01;
                }
                else {
                    return CKR_ARGUMENTS_BAD;
                }
		    } else {
                alg = 0x00;
		    }
			break;
		case CKM_SM2_SM3_256:
			alg = 0x07;
			break;
		case CKM_ECDSA:
		default:
			return CKR_FUNCTION_NOT_SUPPORTED;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_asymAlgOpera);

#if 0
	while(sendLen < length) {
		off = 0;
		//session
		if(key->isToken == CK_FALSE) {
			buf[off++] = 0x11;
			buf[off++] = alg;
			buf[off++] = (u8)(key->key.value.length >> 8);
			buf[off++] = (u8)(key->key.value.length & 0x00ff);
			memcpy(buf+off, key->key.value.data, key->key.value.length);//key cipher
			off += key->key.value.length;
		}
			//token
		else {
			buf[off++] = 0x01;
			buf[off++] = alg;
			buf[off++] = (u8)((key->key.fid) >> 8);
			buf[off++] = (u8)((key->key.fid) & 0x00FF);
		}

		len = (u8)((SC_MAX_SEND_BUFF_CFG_SIZE - off) & 0xF0);//send fixed length everytime

		if((length - sendLen) < len) {
			len = length - sendLen;
		}

		buf[off++] = (u8)(len >> 8);
		buf[off++] = (u8)(len & 0x00ff);

		memcpy(buf+off, cipher+sendLen, len);//cipher text
		sendLen += len;

		apdu->lc = off+len;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		apdu->le = 0;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			memcpy(cipher+clen, apdu->resp, apdu->resplen);
			clen += apdu->resplen;
		}
	}
#else

	//session
	if(key->isToken == CK_FALSE) {
		apduBuf[dataLen++] = 0x11;
		apduBuf[dataLen++] = alg;
		apduBuf[dataLen++] = (u8)(key->key.value.length >> 8);
		apduBuf[dataLen++] = (u8)(key->key.value.length & 0x00ff);
		memcpy(apduBuf+dataLen, key->key.value.data, key->key.value.length);//key cipher
		dataLen += key->key.value.length;
	}
		//token
	else {
		apduBuf[dataLen++] = 0x01;
		apduBuf[dataLen++] = alg;
		apduBuf[dataLen++] = (u8)((key->key.fid) >> 8);
		apduBuf[dataLen++] = (u8)((key->key.fid) & 0x00FF);
	}
	apduBuf[dataLen++] = (u8)(length >> 8);
	apduBuf[dataLen++] = (u8)(length & 0x00ff);
	memcpy(apduBuf+dataLen, cipher, length);//cipher text
	dataLen += length;

	if (dataLen <= SC_MAX_SEND_BUFF_CFG_SIZE) {
		apdu->p1 = 0x00;//unique block
		memcpy(buf, apduBuf, dataLen);

		apdu->lc = dataLen;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		apdu->le = 0x00;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}
	else {

		while (off < dataLen) {

			if ((dataLen - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
				len = SC_MAX_SEND_BUFF_CFG_SIZE;
				if (off == 0x00) {
					apdu->p1 = 0x01;//first block
				} else {
					apdu->p1 = 0x02;//mid block
				}
			} else {
				len = (dataLen - off);
				apdu->p1 = 0x03;//last block
			}

			memcpy(buf, apduBuf+off, len);
			off += len;

			apdu->lc = len;
			apdu->data = buf;
			apdu->datalen = apdu->lc;

			apdu->le = 0x00;
			apdu->resp = buf;
			apdu->resplen = apdu->le;

			rv = tmc_transmit_apdu(card, apdu);
			if (rv != CKR_OK) {
				goto out;
			}

			rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
			if (rv != CKR_OK) {
				goto out;
			}
		}
	}

	if (apdu->resplen != 0x00) {
		if ((clen + apdu->resplen) > SC_MAX_CACHE_SIZE) {
			rv = CKR_BUFFER_TOO_SMALL;
			goto out;
		}
		memcpy(apduBuf + clen, apdu->resp, apdu->resplen);
		clen += apdu->resplen;
	}

	while(apdu->sw1 == 0x95) {

		tmc_format_apdu(apdu, SC_APDU_CASE_2_SHORT, apdu_getRespData);

		apdu->lc = apdu->sw2;
		apdu->resp = buf;
		apdu->resplen = apdu->lc;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			if((clen + apdu->resplen) > SC_MAX_CACHE_SIZE) {
				rv = CKR_BUFFER_TOO_SMALL;
				goto out;
			}
			memcpy(apduBuf+clen, apdu->resp, apdu->resplen);
			clen += apdu->resplen;
		}
	}
#endif
	if(plain != NULL) {
		if((unsigned int)clen > (unsigned int)(*plain_len)) {
			rv = CKR_BUFFER_TOO_SMALL;
			goto out;
		}
		memcpy(plain, apduBuf, clen);
	}
	*plain_len = clen;

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_sign_data(struct tmc_card *card, CK_ULONG mechanism, CK_ULONG keytype, tmcse_key_t *key, u8 *hash, CK_ULONG length, u8 *signature, CK_ULONG *sign_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len,alg;
    CK_ULONG off=0,clen=0,dataLen=0;

	if((card == NULL) || (key == NULL) || (hash == NULL) || (sign_len == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((length == 0)||(length > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	switch(mechanism) {
		case CKM_RSA_PKCS://RSA noPadding
        case CKM_RSA_X_509:
            if(key->isToken == CK_FALSE) {
                if(keytype == RSA_KEY_TYPE_ND) {
                    alg = 0x0B;
                }
                else if(keytype == RSA_KEY_TYPE_CRT) {
                    alg = 0x0C;
                }
                else {
                    return CKR_ARGUMENTS_BAD;
                }
            } else {
                alg = 0x0B;
            }
		    break;
		case CKM_RSA_9796 :
		case CKM_MD5_RSA_PKCS:
		case CKM_SHA1_RSA_PKCS :
		case CKM_SHA224_RSA_PKCS:
		case CKM_SHA256_RSA_PKCS:
		case CKM_SHA384_RSA_PKCS:
		case CKM_SHA512_RSA_PKCS:
		case CKM_RIPEMD160_RSA_PKCS:
            if(key->isToken == CK_FALSE) {
                if(keytype == RSA_KEY_TYPE_ND) {
                    alg = 0x00;
                }
                else if(keytype == RSA_KEY_TYPE_CRT) {
                    alg = 0x01;
                }
                else {
                    return CKR_ARGUMENTS_BAD;
                }
            } else {
                alg = 0x00;
            }
			break;
		case CKM_SM2_SM3_256:
		case CKM_SM2_SM3_256_E:
			alg = 0x09;
			break;
		//case CKM_ECDSA_SHA1:
		//	alg = 0x06;
		//	break;
		case CKM_ECDSA:
		case CKM_ECDSA_SHA256:
			alg = 0x0A;
			break;
		default:
			return CKR_FUNCTION_NOT_SUPPORTED;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_asymAlgOpera);

	//token
	if(key->isToken == CK_TRUE) {
		apduBuf[dataLen++] = 0x02;
		apduBuf[dataLen++] = alg;
		apduBuf[dataLen++] = (u8) ((key->key.fid) >> 8);
		apduBuf[dataLen++] = (u8) ((key->key.fid) & 0x00FF);//fid
		apduBuf[dataLen++] = (u8) (length >> 8);
		apduBuf[dataLen++] = (u8) (length & 0x00FF);
		memcpy(apduBuf+dataLen, hash, length);//hash value
		dataLen += length;
	}
	//session
	else {
		apduBuf[dataLen++] = 0x12;
		apduBuf[dataLen++] = alg;
		apduBuf[dataLen++] = (u8) (key->key.value.length >> 8);
		apduBuf[dataLen++] = (u8) (key->key.value.length & 0x00ff);
		memcpy(apduBuf+dataLen, key->key.value.data, key->key.value.length);//cipher prikey value
		dataLen += key->key.value.length;
		apduBuf[dataLen++] = (u8) (length >> 8);
		apduBuf[dataLen++] = (u8) (length & 0x00ff);
		memcpy(apduBuf+dataLen, hash, length);//hash value
		dataLen += length;
	}

	if (dataLen <= SC_MAX_SEND_BUFF_CFG_SIZE) {
		apdu->p1 = 0x00;//unique block
		memcpy(buf, apduBuf, dataLen);

		apdu->lc = dataLen;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		apdu->le = 0x00;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}
	else {
	
		while (off < dataLen) {

			if ((dataLen - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
				len = SC_MAX_SEND_BUFF_CFG_SIZE;
				if (off == 0x00) {
					apdu->p1 = 0x01;//first block
				} else {
					apdu->p1 = 0x02;//mid block
				}
			} else {
				len = (dataLen - off);
				apdu->p1 = 0x03;//last block
			}

			memcpy(buf, apduBuf+off, len);
			off += len;

			apdu->lc = len;
			apdu->data = buf;
			apdu->datalen = apdu->lc;

			apdu->le = 0x00;
			apdu->resp = buf;
			apdu->resplen = apdu->le;

			rv = tmc_transmit_apdu(card, apdu);
			if (rv != CKR_OK) {
				goto out;
			}

			rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
			if (rv != CKR_OK) {
				goto out;
			}
		}
	}

	if (apdu->resplen != 0x00) {
		if ((clen + apdu->resplen) > SC_MAX_CACHE_SIZE) {
			rv = CKR_BUFFER_TOO_SMALL;
			goto out;
		}
		memcpy(apduBuf + clen, apdu->resp, apdu->resplen);
		clen += apdu->resplen;
	}

	while(apdu->sw1 == 0x95) {
	
		tmc_format_apdu(apdu, SC_APDU_CASE_2_SHORT, apdu_getRespData);

		apdu->lc = apdu->sw2;
		apdu->resp = buf;
		apdu->resplen = apdu->lc;
		
		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			if((clen + apdu->resplen) > SC_MAX_CACHE_SIZE) {
				rv = CKR_BUFFER_TOO_SMALL;
				goto out;
			}
			memcpy(apduBuf+clen, apdu->resp, apdu->resplen);
			clen += apdu->resplen;
		}
	}

	if(signature != NULL) {
		if((unsigned int)clen > (unsigned int)(*sign_len)) {
			//rv = CKR_BUFFER_TOO_SMALL;
			//goto out;
		}
		memcpy(signature, apduBuf, clen);
	}
	*sign_len = clen;

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_verify_sign(struct tmc_card *card, CK_ULONG mechanism, tmcse_key_t *key, u8 *hash, CK_ULONG length, u8 *signature, CK_ULONG sign_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len,alg;
	CK_ULONG off=0,dataLen=0;

	if((card == NULL) || (key == NULL) || (hash == NULL) || (signature == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((length == 0)||(length > SC_MAX_LENGTH_SIZE)||(sign_len == 0)||(sign_len > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	switch(mechanism) {
		case CKM_RSA_PKCS:
        case CKM_RSA_X_509:
			alg = 0x0B;
			break;
		case CKM_RSA_9796 :
		case CKM_MD5_RSA_PKCS:
		case CKM_SHA1_RSA_PKCS :
		case CKM_SHA224_RSA_PKCS:
		case CKM_SHA256_RSA_PKCS:
		case CKM_SHA384_RSA_PKCS:
		case CKM_SHA512_RSA_PKCS:
		case CKM_RIPEMD160_RSA_PKCS:
			alg = 0x00;
			break;
		case CKM_SM2_SM3_256:
		case CKM_SM2_SM3_256_E:
			alg = 0x09;
			break;
		case CKM_ECDSA_SHA1:
        case CKM_ECDSA_SHA256:
		case CKM_ECDSA:
		    alg = 0x0A;
			//alg = 0x06;
			break;
		default:
			return CKR_FUNCTION_NOT_SUPPORTED;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_3_SHORT, apdu_asymAlgOpera);

	//token
	if(key->isToken == CK_TRUE) {
		apduBuf[dataLen++] = 0x03;
		apduBuf[dataLen++] = alg;
		apduBuf[dataLen++] = (u8) ((key->key.fid) >> 8);
		apduBuf[dataLen++] = (u8) ((key->key.fid) & 0x00FF);//fid
		apduBuf[dataLen++] = (u8) (sign_len >> 8);
		apduBuf[dataLen++] = (u8) (sign_len & 0x00FF);
		memcpy(apduBuf+dataLen, signature, sign_len);//signature value
		dataLen += sign_len;
		apduBuf[dataLen++] = (u8) (length >> 8);
		apduBuf[dataLen++] = (u8) (length & 0x00FF);
		memcpy(apduBuf+dataLen, hash, length);//hash value
		dataLen += length;
	}
	//session
	else {
		apduBuf[dataLen++] = 0x13;
		apduBuf[dataLen++] = alg;
		apduBuf[dataLen++] = (u8) ((key->key.value.length) >> 8);
		apduBuf[dataLen++] = (u8) ((key->key.value.length) & 0x00FF);
		memcpy(apduBuf+dataLen, key->key.value.data, key->key.value.length);//pubkey value
		dataLen += key->key.value.length;
		apduBuf[dataLen++] = (u8) (sign_len >> 8);
		apduBuf[dataLen++] = (u8) (sign_len & 0x00FF);
		memcpy(apduBuf+dataLen, signature, sign_len);//signature value
		dataLen += sign_len;
		apduBuf[dataLen++] = (u8) (length >> 8);
		apduBuf[dataLen++] = (u8) (length & 0x00FF);
		memcpy(apduBuf+dataLen, hash, length);//hash value
		dataLen += length;
	}

	if (dataLen <= SC_MAX_SEND_BUFF_CFG_SIZE) {
		apdu->p1 = 0x00;//unique block
		memcpy(buf, apduBuf, dataLen);

		apdu->lc = dataLen;
		apdu->data = buf;
		apdu->datalen = apdu->lc;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}
	} else {
		while (off < dataLen) {

			if ((dataLen - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
				len = SC_MAX_SEND_BUFF_CFG_SIZE;
				if (off == 0x00) {
					apdu->p1 = 0x01;//first block
				} else {
					apdu->p1 = 0x02;//mid block
				}
			} else {
				len = (dataLen - off);
				apdu->p1 = 0x03;//last block
			}

			memcpy(buf, apduBuf + off, len);
			off += len;

			apdu->lc = len;
			apdu->data = buf;
			apdu->datalen = apdu->lc;

			rv = tmc_transmit_apdu(card, apdu);
			if (rv != CKR_OK) {
				goto out;
			}

			rv = tmc_check_sw(card, apdu->sw1, apdu->sw2);
			if (rv != CKR_OK) {
				goto out;
			}
		}
	}
	
	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_hash_data(struct tmc_card *card, CK_ULONG mechanism, u8 *data, CK_ULONG length, u8 *hash, CK_ULONG *hash_len)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len,alg;
	CK_ULONG off=0;

	if((card == NULL) || (data == NULL) || (hash_len == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((length == 0)||(length > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	switch(mechanism) {
		case CKM_SHA_1:
			alg = 0x01;
			break;
		case CKM_SHA256:
			alg = 0x02;
			break;
		case CKM_SHA224:
		case CKM_SHA384:
		case CKM_SHA512:
		default:
			return CKR_FUNCTION_NOT_SUPPORTED;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_hashOpera);

	buf[off++] = alg;
	buf[off++] = (u8)(length >> 8);
	buf[off++] = (u8)(length & 0x00ff);

	if(length > (SC_MAX_SEND_BUFF_CFG_SIZE - off)) {
		len = (SC_MAX_SEND_BUFF_CFG_SIZE - off);
		apdu->p1 = 0x01;//first block
	}
	else {
		len = length;
		apdu->p1 = 0x00;//unique block
	}

	memcpy(buf+off, data, len);//value

	apdu->lc = off+len;
	apdu->data = buf;
	apdu->datalen = apdu->lc;

	apdu->le = 0x00;
	apdu->resp = buf;
	apdu->resplen = apdu->le;
	
	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	if(apdu->resplen != 0x00) {
		if(hash != NULL) {
			if((unsigned int)apdu->resplen > (unsigned int)(*hash_len)) {
				rv = CKR_BUFFER_TOO_SMALL;
				goto out;
			}
			memcpy(hash, apdu->resp, apdu->resplen);
		}
		*hash_len = apdu->resplen;
	}

	off = 0;
	while((off+len) < length) {
		
		tmc_format_apdu(apdu, SC_APDU_CASE_4_SHORT, apdu_hashOpera);

		off += len;

		if((length - off) > SC_MAX_SEND_BUFF_CFG_SIZE) {
			len = SC_MAX_SEND_BUFF_CFG_SIZE;
			apdu->p1 = 0x02;//mid block
		}
		else {
			len = (length - off);
			apdu->p1 = 0x03;//last block
		}

		memcpy(buf, data+off, len);//value

		apdu->lc = len;
		apdu->data = buf;
		apdu->datalen = apdu->lc;
		
		apdu->le = 0x00;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

	}

	if(apdu->resplen != 0x00) {
		if(hash != NULL) {
			if((unsigned int)apdu->resplen > (unsigned int)(*hash_len)) {
				rv = CKR_BUFFER_TOO_SMALL;
				goto out;
			}
			memcpy(hash, apdu->resp, apdu->resplen);
		}
	}
	*hash_len = apdu->resplen;

	out:
	free(apdu);
	return rv;
}


//other operation
CK_RV tmcse_get_challenge(struct tmc_card *card, CK_ULONG length, u8 *random)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
	u8 len;
	CK_ULONG i;

	if((card == NULL) || (random == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	if((length == 0)||(length > SC_MAX_LENGTH_SIZE)) {
		return CKR_DATA_LEN_RANGE;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	for(i=0; i<length; i+=len) {
		
		len = (u8)(((length-i) > SC_MAX_SEND_BUFF_CFG_SIZE) ? (SC_MAX_SEND_BUFF_CFG_SIZE) : (length-i));

		tmc_format_apdu(apdu, SC_APDU_CASE_2_SHORT, apdu_getChallenge);

		apdu->le = len;
		apdu->resp = buf;
		apdu->resplen = apdu->le;

		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}

		if(apdu->resplen != 0x00) {
			memcpy(random+i, apdu->resp, apdu->resplen);
		}
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_get_uid(struct tmc_card *card, u8 *uid, CK_ULONG *length)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};

	if((card == NULL) || (length == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_2_SHORT, apdu_getUID);

	apdu->le = 0x00;
	apdu->resp = buf;
	apdu->resplen = apdu->le;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	if(apdu->resplen != 0x00) {
		if(uid != NULL) {
			if(apdu->resplen > (unsigned int)(*length)) {
				rv = CKR_BUFFER_TOO_SMALL;
				goto out;
			}
			memcpy(uid, apdu->resp, apdu->resplen);
		}
	}
	*length = apdu->resplen;		
	
	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_get_card_state(struct tmc_card *card, u8 *state)
{
	CK_RV rv;
	tmc_apdu_t *apdu;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};

	if((card == NULL) || (state == NULL)) {
		return CKR_ARGUMENTS_BAD;
	}

	apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
	if(apdu == NULL) {
		return CKR_HOST_MEMORY;
	}

	tmc_format_apdu(apdu, SC_APDU_CASE_2_SHORT, apdu_getInfo);

	apdu->p1 = 0x04;
	
	apdu->le = 0x01;
	apdu->resp = buf;
	apdu->resplen = apdu->le;

	rv = tmc_transmit_apdu(card, apdu);
	if (rv != CKR_OK) {
		goto out;
	}

	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		goto out;
	}

	if(apdu->resplen != 0x00) {
		*state = apdu->resp[0];
	}

	out:
	free(apdu);
	return rv;
}

CK_RV tmcse_self(struct tmc_card *card, u8* cmd, u8 cse, CK_BBOOL isReset)
{
	CK_RV rv;
	CK_BYTE_PTR data_ptr = cmd + DATA_OFFSET;
	tmc_apdu_t *apdu;
    u8 buf[SC_MAX_APDU_BUFFER_SIZE] = {0};
    if(card == NULL) {
        return CKR_ARGUMENTS_BAD;
    }
    apdu = (struct tmc_apdu*)malloc(sizeof(*apdu));
    if(apdu == NULL) {
        return CKR_HOST_MEMORY;
    }

	tmc_format_apdu(apdu, cse, cmd);

	switch(apdu->cse) {
		case SC_APDU_CASE_1:
			break;
		case SC_APDU_CASE_2_SHORT:
			apdu->le = cmd[LC_OFFSET];
			apdu->data = buf;
			apdu->resp = buf;
			apdu->resplen = (unsigned int)apdu->le;
			break;
		case SC_APDU_CASE_3_SHORT:
			apdu->lc = cmd[LC_OFFSET];
			memcpy(buf, cmd + DATA_OFFSET, apdu->lc);
			apdu->data = buf;
            apdu->resp = buf;
			apdu->datalen = apdu->lc;
			break;
		case SC_APDU_CASE_4_SHORT:
			apdu->lc = cmd[LC_OFFSET];
			apdu->le = cmd[DATA_OFFSET + apdu->lc];
			memcpy(buf, cmd + DATA_OFFSET, apdu->lc);
			apdu->data = buf;
			apdu->datalen = apdu->lc;
			apdu->resp = buf;
			apdu->resplen = (unsigned int)apdu->le;
			break;
		default:
			break;
	}

    rv = tmc_transmit_apdu(card, apdu);
    if (rv != CKR_OK) {
        goto out;
    }

    if(!isReset) {
        rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
        if (rv != CKR_OK) {
            goto out;
        }
    }
    else {// first cmd can send again
	rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
	if (rv != CKR_OK) {
		rv = tmc_transmit_apdu(card, apdu);
		if (rv != CKR_OK) {
			goto out;
		}

		rv =  tmc_check_sw(card, apdu->sw1, apdu->sw2);
		if (rv != CKR_OK) {
			goto out;
		}
	}
    }

    if(apdu->resplen)
        memcpy(cmd, apdu->resp, apdu->resplen);

	out:
	free(apdu);
	return rv;
}


static struct tmc_card_operations tmcse_ops = {
		tmcse_init,
		tmcse_create_alg,
		tmcse_create_df,
		tmcse_create_pin,
		tmcse_create_bin,
		tmcse_create_object,
		tmcse_delete_file,
		tmcse_select_MF,
		tmcse_select_fid,
		tmcse_select_file,
		tmcse_write_pin,
		tmcse_read_binary,
		tmcse_update_binary,
		tmcse_read_binary_by_sfi,
		tmcse_update_binary_by_sfi,
		tmcse_read_object,
		tmcse_update_object,
		tmcse_end_personal,
		tmcse_verify_pin,
		tmcse_change_pin,
		tmcse_verify_tk,
		tmcse_change_tk,
		tmcse_get_pin_info,
		tmcse_clear_pin_state,
		tmcse_generate_key,
		tmcse_generate_key_ex,
		tmcse_generate_keypair,
		tmcse_generate_keypair_ex,
		tmcse_import_key,
		tmcse_import_pubkey,
		tmcse_import_prikey,
		tmcse_enc_key,
		tmcse_export_pubkey,
		tmcse_wrap_key,
		tmcse_unwrap_key,
		tmcse_unwrap_key_ex,
		tmcse_ecc_exchangekey,
		tmcse_ecc_exchangekey_ex,
		tmcse_sm2_exchangekey,
		tmcse_sm2_exchangekey_ex,
		tmcse_dh_exchangekey,
		tmcse_dh_exchangekey_ex,
		tmcse_enc_data,
		tmcse_dec_data,
		tmcse_encrypt,
		tmcse_decrypt,
		tmcse_sign_data,
		tmcse_verify_sign,
		tmcse_hash_data,
		tmcse_get_challenge,
		tmcse_get_uid,
		tmcse_get_card_state,
		tmcse_self,
		tmcse_finish
};
struct tmc_card_operations* tmc_get_card_driver()
{
	return &tmcse_ops;
}



